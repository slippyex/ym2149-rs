<!doctype html>
<html lang="en" class="scroll-smooth">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>YM2149 Web Player</title>
        <meta
            name="description"
            content="Play YM2149 chiptunes directly in your browser. Browse 8000+ tracks from SNDH, YM, AY, and Arkos collections."
        />
        <meta property="og:title" content="YM2149 Web Player" />
        <meta
            property="og:description"
            content="Play YM2149 chiptunes directly in your browser with real-time visualization."
        />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://ym2149-rs.org/demo/" />
        <link rel="canonical" href="https://ym2149-rs.org/demo/" />
        <link
            rel="icon"
            type="image/svg+xml"
            href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŽµ</text></svg>"
        />
        <script src="https://cdn.tailwindcss.com"></script>
        <script>
            tailwind.config = {
                theme: {
                    extend: {
                        colors: {
                            chip: {
                                dark: "#0a0a0f",
                                darker: "#05050a",
                                purple: "#8b5cf6",
                                cyan: "#06b6d4",
                                pink: "#ec4899",
                                green: "#10b981",
                            },
                        },
                        fontFamily: {
                            mono: ["JetBrains Mono", "Fira Code", "monospace"],
                            display: [
                                "Space Grotesk",
                                "system-ui",
                                "sans-serif",
                            ],
                        },
                    },
                },
            };
        </script>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap"
            rel="stylesheet"
        />
        <style>
            body {
                background: #05050a;
                background-image:
                    radial-gradient(
                        ellipse at 20% 0%,
                        rgba(139, 92, 246, 0.08) 0%,
                        transparent 50%
                    ),
                    radial-gradient(
                        ellipse at 80% 100%,
                        rgba(6, 182, 212, 0.06) 0%,
                        transparent 50%
                    );
                background-attachment: fixed;
            }

            .gradient-text {
                background: linear-gradient(
                    135deg,
                    #8b5cf6 0%,
                    #06b6d4 50%,
                    #ec4899 100%
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                text-shadow: 0 0 30px rgba(139, 92, 246, 0.3);
            }

            /* Modern auto-hiding scrollbar */
            * {
                scrollbar-width: thin;
                scrollbar-color: transparent transparent;
            }
            *:hover {
                scrollbar-color: rgba(139, 92, 246, 0.5) transparent;
            }
            ::-webkit-scrollbar {
                width: 6px;
                height: 6px;
            }
            ::-webkit-scrollbar-track {
                background: transparent;
            }
            ::-webkit-scrollbar-thumb {
                background: transparent;
                border-radius: 6px;
                transition: background 0.3s ease;
            }
            *:hover::-webkit-scrollbar-thumb {
                background: rgba(139, 92, 246, 0.3);
            }
            *:hover::-webkit-scrollbar-thumb:hover {
                background: rgba(139, 92, 246, 0.6);
            }

            /* Range inputs with glow */
            input[type="range"] {
                -webkit-appearance: none;
                appearance: none;
                background: transparent;
                cursor: pointer;
            }
            input[type="range"]::-webkit-slider-track {
                background: rgba(255, 255, 255, 0.1);
                height: 4px;
                border-radius: 2px;
            }
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 14px;
                height: 14px;
                background: linear-gradient(135deg, #8b5cf6, #06b6d4);
                border-radius: 50%;
                margin-top: -5px;
                box-shadow:
                    0 0 10px rgba(139, 92, 246, 0.6),
                    0 0 20px rgba(6, 182, 212, 0.3);
                transition:
                    transform 0.15s,
                    box-shadow 0.15s;
            }
            input[type="range"]::-webkit-slider-thumb:hover {
                transform: scale(1.2);
                box-shadow:
                    0 0 15px rgba(139, 92, 246, 0.8),
                    0 0 30px rgba(6, 182, 212, 0.5);
            }
            input[type="range"]::-moz-range-track {
                background: rgba(255, 255, 255, 0.1);
                height: 4px;
                border-radius: 2px;
            }
            input[type="range"]::-moz-range-thumb {
                width: 14px;
                height: 14px;
                background: linear-gradient(135deg, #8b5cf6, #06b6d4);
                border-radius: 50%;
                border: none;
                box-shadow: 0 0 10px rgba(139, 92, 246, 0.6);
            }

            /* Track row with glow hover effect */
            .track-row {
                transition: all 0.2s ease;
                position: relative;
            }
            .track-row::before {
                content: "";
                position: absolute;
                inset: 0;
                background: linear-gradient(
                    90deg,
                    rgba(139, 92, 246, 0.15) 0%,
                    rgba(6, 182, 212, 0.1) 50%,
                    transparent 100%
                );
                opacity: 0;
                transition: opacity 0.3s ease;
                pointer-events: none;
            }
            .track-row:hover::before {
                opacity: 1;
            }
            .track-row:hover {
                background: rgba(139, 92, 246, 0.05);
                box-shadow: inset 0 0 30px rgba(139, 92, 246, 0.05);
            }
            .track-row.active {
                background: rgba(139, 92, 246, 0.12);
                box-shadow:
                    inset 0 0 20px rgba(139, 92, 246, 0.1),
                    0 0 15px rgba(139, 92, 246, 0.1);
            }
            .track-row.playing {
                background: linear-gradient(
                    90deg,
                    rgba(6, 182, 212, 0.15) 0%,
                    rgba(139, 92, 246, 0.1) 100%
                );
                box-shadow:
                    inset 0 0 30px rgba(6, 182, 212, 0.1),
                    0 0 20px rgba(6, 182, 212, 0.15);
            }

            /* Favorite button glow */
            .fav-btn {
                opacity: 0.4;
                transition: all 0.2s ease;
                filter: drop-shadow(0 0 0 transparent);
            }
            .fav-btn:hover {
                opacity: 1;
                transform: scale(1.2);
                filter: drop-shadow(0 0 8px rgba(239, 68, 68, 0.6));
            }
            .fav-btn.text-red-500 {
                opacity: 1;
                filter: drop-shadow(0 0 6px rgba(239, 68, 68, 0.5));
            }
            .track-row:hover .fav-btn {
                opacity: 0.7;
            }
            .track-row:hover .fav-btn.text-red-500 {
                opacity: 1;
            }

            /* Collection tabs with glow */
            .collection-tab {
                transition: all 0.2s ease;
                position: relative;
                overflow: hidden;
            }
            .collection-tab::after {
                content: "";
                position: absolute;
                inset: 0;
                background: linear-gradient(
                    135deg,
                    rgba(255, 255, 255, 0.1) 0%,
                    transparent 50%
                );
                opacity: 0;
                transition: opacity 0.2s;
            }
            .collection-tab:hover::after {
                opacity: 1;
            }
            .collection-tab.active {
                background: rgba(139, 92, 246, 0.25);
                border-color: rgba(139, 92, 246, 0.6);
                box-shadow:
                    0 0 15px rgba(139, 92, 246, 0.3),
                    inset 0 0 10px rgba(139, 92, 246, 0.1);
            }

            .virtual-list {
                overflow-y: auto;
                will-change: transform;
            }

            /* Visualization canvas with subtle glow */
            .viz-canvas {
                image-rendering: pixelated;
                image-rendering: crisp-edges;
                box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
            }

            /* Pulsing glow animation */
            @keyframes pulse-glow {
                0%,
                100% {
                    box-shadow:
                        0 0 20px rgba(139, 92, 246, 0.4),
                        0 0 40px rgba(139, 92, 246, 0.2);
                }
                50% {
                    box-shadow:
                        0 0 30px rgba(6, 182, 212, 0.5),
                        0 0 60px rgba(6, 182, 212, 0.3);
                }
            }
            .playing-indicator {
                animation: pulse-glow 2s ease-in-out infinite;
            }

            /* Shimmer animation for loading states */
            @keyframes shimmer {
                0% {
                    background-position: -200% 0;
                }
                100% {
                    background-position: 200% 0;
                }
            }
            .shimmer {
                background: linear-gradient(
                    90deg,
                    transparent 0%,
                    rgba(255, 255, 255, 0.1) 50%,
                    transparent 100%
                );
                background-size: 200% 100%;
                animation: shimmer 2s infinite;
            }

            /* Glow button styles */
            .glow-btn {
                position: relative;
                transition: all 0.2s ease;
            }
            .glow-btn::before {
                content: "";
                position: absolute;
                inset: -2px;
                background: linear-gradient(135deg, #8b5cf6, #06b6d4, #ec4899);
                border-radius: inherit;
                opacity: 0;
                z-index: -1;
                filter: blur(8px);
                transition: opacity 0.3s;
            }
            .glow-btn:hover::before {
                opacity: 0.6;
            }

            .search-highlight {
                background: rgba(236, 72, 153, 0.3);
                border-radius: 2px;
                box-shadow: 0 0 8px rgba(236, 72, 153, 0.4);
            }

            /* Author header with gradient border */
            .author-header {
                background: linear-gradient(
                    90deg,
                    rgba(139, 92, 246, 0.12) 0%,
                    rgba(6, 182, 212, 0.08) 100%
                );
                border-left: 2px solid;
                border-image: linear-gradient(180deg, #8b5cf6, #06b6d4) 1;
                cursor: pointer;
                user-select: none;
                transition: all 0.2s ease;
            }
            .author-header:hover {
                background: linear-gradient(
                    90deg,
                    rgba(139, 92, 246, 0.18) 0%,
                    rgba(6, 182, 212, 0.12) 100%
                );
                box-shadow: inset 0 0 20px rgba(139, 92, 246, 0.1);
            }
            .collapse-chevron {
                transition: transform 0.2s ease;
            }
            .collapse-chevron.collapsed {
                transform: rotate(-90deg);
            }

            /* Panel glow effect */
            .panel-glow {
                box-shadow:
                    0 0 30px rgba(139, 92, 246, 0.1),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05);
            }

            /* Waveform scrubber glow */
            #waveformScrubber {
                box-shadow:
                    0 0 20px rgba(139, 92, 246, 0.2),
                    inset 0 0 30px rgba(0, 0, 0, 0.3);
                transition: box-shadow 0.3s ease;
                touch-action: none; /* Prevent browser scrolling during scrub */
            }
            #waveformScrubber:hover {
                box-shadow:
                    0 0 30px rgba(139, 92, 246, 0.3),
                    0 0 60px rgba(6, 182, 212, 0.15),
                    inset 0 0 30px rgba(0, 0, 0, 0.3);
            }

            /* Similar tracks button glow */
            .similar-track {
                transition: all 0.2s ease;
                border: 1px solid transparent;
            }
            .similar-track:hover {
                border-color: rgba(139, 92, 246, 0.3);
                box-shadow: 0 0 15px rgba(139, 92, 246, 0.2);
                transform: translateY(-1px);
            }

            /* Channel mute buttons glow when active */
            .channel-btn {
                transition: all 0.2s ease;
            }
            .channel-btn:hover {
                transform: scale(1.05);
                filter: brightness(1.2);
            }
            .channel-btn.muted {
                filter: grayscale(0.8) brightness(0.6);
            }

            /* Toast notification glow */
            #toast {
                box-shadow:
                    0 0 30px rgba(139, 92, 246, 0.4),
                    0 4px 20px rgba(0, 0, 0, 0.3);
            }

            /* Play button glow effects */
            #playBtn {
                box-shadow:
                    0 0 20px rgba(139, 92, 246, 0.4),
                    0 0 40px rgba(6, 182, 212, 0.2);
                transition: all 0.3s ease;
                position: relative;
            }
            #playBtn::before {
                content: "";
                position: absolute;
                inset: -3px;
                background: linear-gradient(135deg, #8b5cf6, #06b6d4, #ec4899);
                border-radius: 50%;
                opacity: 0;
                z-index: -1;
                filter: blur(10px);
                transition: opacity 0.3s;
            }
            #playBtn:hover:not(:disabled)::before {
                opacity: 0.7;
            }
            #playBtn:hover:not(:disabled) {
                box-shadow:
                    0 0 30px rgba(139, 92, 246, 0.6),
                    0 0 60px rgba(6, 182, 212, 0.3);
                transform: scale(1.05);
            }
            #playBtn:active:not(:disabled) {
                transform: scale(0.98);
            }
            #playBtn.playing {
                animation: play-pulse 2s ease-in-out infinite;
            }
            @keyframes play-pulse {
                0%,
                100% {
                    box-shadow:
                        0 0 20px rgba(6, 182, 212, 0.5),
                        0 0 40px rgba(139, 92, 246, 0.3);
                }
                50% {
                    box-shadow:
                        0 0 35px rgba(6, 182, 212, 0.7),
                        0 0 70px rgba(139, 92, 246, 0.4);
                }
            }

            /* Control buttons (stop, prev, next) glow */
            .control-btn {
                transition: all 0.2s ease;
                position: relative;
            }
            .control-btn::after {
                content: "";
                position: absolute;
                inset: 0;
                border-radius: 50%;
                box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
                pointer-events: none;
            }
            .control-btn:hover:not(:disabled) {
                background: linear-gradient(
                    135deg,
                    rgba(139, 92, 246, 0.3),
                    rgba(6, 182, 212, 0.2)
                ) !important;
                box-shadow: 0 0 15px rgba(139, 92, 246, 0.3);
                transform: scale(1.1);
            }
            .control-btn:active:not(:disabled) {
                transform: scale(0.95);
            }

            /* Shuffle/repeat toggle glow when active */
            .toggle-btn {
                transition: all 0.2s ease;
            }
            .toggle-btn:hover {
                filter: brightness(1.3);
            }
            .toggle-btn.active {
                filter: drop-shadow(0 0 6px currentColor);
            }

            /* Volume control glow */
            #volumeBtn {
                transition: all 0.2s ease;
            }
            #volumeBtn:hover {
                filter: drop-shadow(0 0 8px rgba(139, 92, 246, 0.5));
                transform: scale(1.1);
            }

            /* Header logo glow */
            header .w-8.h-8 {
                box-shadow: 0 0 15px rgba(139, 92, 246, 0.4);
                transition: all 0.3s ease;
            }
            header a:hover .w-8.h-8 {
                box-shadow:
                    0 0 25px rgba(139, 92, 246, 0.6),
                    0 0 50px rgba(6, 182, 212, 0.3);
                transform: scale(1.1) rotate(5deg);
            }

            /* Search input glow */
            #searchInput {
                transition: all 0.2s ease;
            }
            #searchInput:focus {
                box-shadow:
                    0 0 20px rgba(139, 92, 246, 0.3),
                    inset 0 0 10px rgba(139, 92, 246, 0.1);
                border-color: rgba(139, 92, 246, 0.5) !important;
            }

            /* Metadata panel glow effects */
            #metadataPanel {
                background: linear-gradient(
                    180deg,
                    rgba(10, 10, 15, 0.95) 0%,
                    rgba(5, 5, 10, 0.98) 100%
                );
                box-shadow:
                    0 -10px 40px rgba(139, 92, 246, 0.1),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05);
            }

            /* Visualization glow border */
            #vizCanvas {
                box-shadow:
                    0 0 30px rgba(6, 182, 212, 0.2),
                    inset 0 0 50px rgba(0, 0, 0, 0.5);
                border: 1px solid rgba(139, 92, 246, 0.2);
            }

            /* Action buttons (share, export) glow */
            #shareBtn,
            #exportBtn {
                transition: all 0.2s ease;
            }
            #shareBtn:hover,
            #exportBtn:hover {
                background: linear-gradient(
                    135deg,
                    rgba(139, 92, 246, 0.2),
                    rgba(6, 182, 212, 0.15)
                ) !important;
                box-shadow: 0 0 15px rgba(139, 92, 246, 0.3);
                transform: scale(1.1);
            }
            #shareBtn:active,
            #exportBtn:active {
                transform: scale(0.95);
            }

            /* A-B Loop buttons glow when active */
            #loopABtn,
            #loopBBtn {
                transition: all 0.2s ease;
                position: relative;
            }
            #loopABtn:hover:not(:disabled),
            #loopBBtn:hover:not(:disabled) {
                box-shadow: 0 0 10px rgba(6, 182, 212, 0.4);
            }
            #loopABtn.active,
            #loopBBtn.active {
                background: linear-gradient(
                    135deg,
                    rgba(6, 182, 212, 0.4),
                    rgba(139, 92, 246, 0.3)
                ) !important;
                box-shadow: 0 0 15px rgba(6, 182, 212, 0.5);
                color: white !important;
            }
            #loopClearBtn {
                transition: all 0.2s ease;
            }
            #loopClearBtn:hover:not(:disabled) {
                box-shadow: 0 0 10px rgba(239, 68, 68, 0.4);
                background: rgba(239, 68, 68, 0.2) !important;
            }

            /* Visualization mode buttons */
            #vizModeOsc,
            #vizModeSpec {
                transition: all 0.2s ease;
            }
            #vizModeOsc:hover,
            #vizModeSpec:hover {
                transform: translateY(-1px);
            }
            #vizModeOsc.active,
            #vizModeSpec.active {
                box-shadow: 0 0 15px rgba(139, 92, 246, 0.4);
            }

            /* Sidebar glow effect */
            #sidebar {
                background: linear-gradient(
                    180deg,
                    rgba(5, 5, 10, 0.98) 0%,
                    rgba(10, 10, 15, 0.95) 100%
                );
                box-shadow:
                    inset -1px 0 0 rgba(139, 92, 246, 0.1),
                    4px 0 40px rgba(139, 92, 246, 0.05);
            }

            /* Speed select glow */
            #speedSelect {
                transition: all 0.2s ease;
            }
            #speedSelect:hover,
            #speedSelect:focus {
                box-shadow: 0 0 10px rgba(139, 92, 246, 0.3);
                border-color: rgba(139, 92, 246, 0.4);
            }

            /* Subsong selector glow */
            #subsongSelect {
                transition: all 0.2s ease;
            }
            #subsongSelect:hover {
                box-shadow: 0 0 10px rgba(139, 92, 246, 0.3);
                border-color: rgba(139, 92, 246, 0.5);
            }
            #subsongSelect:focus {
                box-shadow: 0 0 15px rgba(139, 92, 246, 0.4);
            }

            /* Oscilloscope channel cards glow */
            .osc-channel {
                transition: all 0.2s ease;
                box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
            }
            .osc-channel:hover {
                box-shadow:
                    0 0 20px rgba(139, 92, 246, 0.15),
                    inset 0 0 20px rgba(0, 0, 0, 0.3);
            }

            /* Register display glow */
            .register-display {
                box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4);
            }
            .register-display:hover {
                box-shadow:
                    0 0 15px rgba(6, 182, 212, 0.15),
                    inset 0 0 30px rgba(0, 0, 0, 0.4);
            }

            /* Floating ambient glow orbs */
            body::before,
            body::after {
                content: "";
                position: fixed;
                border-radius: 50%;
                pointer-events: none;
                z-index: -1;
                opacity: 0.4;
                filter: blur(100px);
            }
            body::before {
                width: 600px;
                height: 600px;
                background: radial-gradient(
                    circle,
                    rgba(139, 92, 246, 0.15) 0%,
                    transparent 70%
                );
                top: -200px;
                left: -100px;
                animation: float-orb 20s ease-in-out infinite;
            }
            body::after {
                width: 500px;
                height: 500px;
                background: radial-gradient(
                    circle,
                    rgba(6, 182, 212, 0.12) 0%,
                    transparent 70%
                );
                bottom: -150px;
                right: -100px;
                animation: float-orb 25s ease-in-out infinite reverse;
            }
            @keyframes float-orb {
                0%,
                100% {
                    transform: translate(0, 0);
                }
                50% {
                    transform: translate(30px, 20px);
                }
            }

            /* Mobile menu button visibility */
            #mobileMenuBtn {
                display: flex;
            }
            @media (min-width: 1024px) {
                #mobileMenuBtn {
                    display: none;
                }
            }

            /* Mobile responsive styles */
            @media (max-width: 1023px) {
                .mobile-hidden {
                    display: none !important;
                }
                .mobile-full {
                    width: 100% !important;
                }
                #sidebar {
                    position: fixed;
                    left: 0;
                    top: 0;
                    bottom: 0;
                    z-index: 40;
                    box-shadow: 4px 0 20px rgba(0, 0, 0, 0.5);
                }
                #sidebar.w-0 {
                    box-shadow: none;
                }
                /* Stack controls vertically on mobile */
                .controls-row {
                    flex-wrap: wrap;
                    gap: 0.5rem;
                }
                .controls-row > div {
                    flex: 1 1 auto;
                    justify-content: center;
                }
            }

            /* Touch-friendly tap targets */
            @media (pointer: coarse) {
                button,
                .collection-tab {
                    min-height: 44px;
                    min-width: 44px;
                }
                .track-row {
                    min-height: 44px;
                }
            }
        </style>
    </head>
    <body
        class="font-display text-gray-100 h-screen flex flex-col overflow-hidden"
    >
        <!-- Header -->
        <header
            class="bg-chip-darker/90 backdrop-blur-lg border-b border-purple-900/20 px-3 py-2 shrink-0"
        >
            <div class="flex items-center justify-between">
                <!-- Mobile menu button -->
                <button
                    id="mobileMenuBtn"
                    class="flex lg:hidden items-center justify-center w-10 h-10 -ml-1 mr-2 text-chip-cyan bg-chip-dark rounded-lg border border-gray-700 active:bg-gray-700"
                    title="Browse tracks"
                >
                    <svg
                        class="w-6 h-6"
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                    >
                        <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            stroke-width="2"
                            d="M4 6h16M4 12h16M4 18h16"
                        />
                    </svg>
                </button>
                <a href="../" class="flex items-center space-x-2">
                    <div
                        class="w-8 h-8 rounded-lg bg-gradient-to-br from-chip-purple to-chip-cyan flex items-center justify-center"
                    >
                        <span class="font-mono font-bold text-xs">YM</span>
                    </div>
                    <span
                        class="font-mono font-semibold text-sm hidden sm:inline"
                        >YM2149 Web Player</span
                    >
                </a>

                <!-- Search -->
                <div class="flex-1 max-w-xs mx-3">
                    <div class="relative">
                        <input
                            type="text"
                            id="searchInput"
                            placeholder="Search..."
                            class="w-full bg-chip-dark border border-gray-800 rounded px-3 py-1.5 pl-8 pr-14 text-sm focus:outline-none focus:border-chip-purple/50"
                        />
                        <svg
                            class="absolute left-2.5 top-2 w-3.5 h-3.5 text-gray-500"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                            />
                        </svg>
                        <span
                            id="searchCount"
                            class="absolute right-6 top-1.5 text-xs text-gray-500 hidden"
                        ></span>
                        <button
                            id="searchClear"
                            class="absolute right-1.5 top-1 p-1 text-gray-500 hover:text-white rounded hidden"
                            title="Clear search"
                        >
                            <svg
                                class="w-3 h-3"
                                fill="none"
                                stroke="currentColor"
                                viewBox="0 0 24 24"
                            >
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="2"
                                    d="M6 18L18 6M6 6l12 12"
                                />
                            </svg>
                        </button>
                    </div>
                </div>

                <div class="flex items-center space-x-2">
                    <label
                        class="cursor-pointer text-xs text-chip-purple hover:text-chip-cyan transition-colors"
                    >
                        <input
                            type="file"
                            id="fileInput"
                            accept=".ym,.aks,.sndh,.ay"
                            class="hidden"
                        />
                        + Load
                    </label>
                    <a
                        href="../"
                        class="text-gray-400 hover:text-white text-xs hidden md:block"
                        >Back</a
                    >
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-1 flex overflow-hidden relative">
            <!-- Mobile sidebar backdrop -->
            <div
                id="sidebarBackdrop"
                class="fixed inset-0 bg-black/60 z-20 hidden lg:hidden"
                aria-hidden="true"
            ></div>

            <!-- Left: Collection Browser -->
            <aside
                id="sidebar"
                class="w-72 lg:w-80 bg-chip-darker border-r border-gray-800 flex flex-col shrink-0 transition-all duration-300 z-30"
            >
                <!-- Sidebar Toggle (visible when collapsed on mobile) -->
                <button
                    id="sidebarToggle"
                    class="absolute left-0 top-1/2 -translate-y-1/2 z-20 bg-chip-darker border border-gray-800 border-l-0 rounded-r-lg p-2 hidden"
                    title="Toggle Browser"
                >
                    <svg
                        class="w-4 h-4"
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                    >
                        <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            stroke-width="2"
                            d="M9 5l7 7-7 7"
                        />
                    </svg>
                </button>
                <!-- Collection Tabs -->
                <div
                    id="collectionTabs"
                    class="flex flex-wrap gap-1 p-2 border-b border-gray-800 text-xs"
                >
                    <!-- Populated by JS -->
                </div>

                <!-- Track List -->
                <div id="trackList" class="virtual-list flex-1 overflow-y-auto">
                    <div id="trackListInner" class="relative">
                        <!-- Tracks rendered here -->
                    </div>
                </div>

                <div
                    class="p-2 border-t border-gray-800 text-xs text-gray-500 flex justify-between items-center"
                >
                    <span><span id="totalTracks">0</span> tracks</span>
                    <button
                        id="toggleCollapseBtn"
                        class="text-chip-purple hover:text-chip-cyan text-xs"
                    >
                        Expand All
                    </button>
                    <span id="filteredCount"></span>
                    <button
                        id="hideSidebarBtn"
                        class="text-gray-500 hover:text-white p-1"
                        title="Hide Browser"
                    >
                        <svg
                            class="w-4 h-4"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M11 19l-7-7 7-7m8 14l-7-7 7-7"
                            />
                        </svg>
                    </button>
                </div>
            </aside>

            <!-- Right: Player & Visualization -->
            <section
                id="playerSection"
                class="flex-1 flex flex-col overflow-y-auto lg:overflow-hidden bg-chip-dark"
            >
                <!-- Now Playing -->
                <div class="p-4 border-b border-gray-800">
                    <div class="flex items-start justify-between gap-4 mb-3">
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <h1
                                    id="songTitle"
                                    class="text-xl font-bold truncate"
                                >
                                    Select a track
                                </h1>
                                <button
                                    id="playerFavBtn"
                                    class="text-gray-600 hover:text-red-400 transition-colors hidden"
                                    title="Add to favorites"
                                >
                                    <svg
                                        class="w-5 h-5"
                                        id="playerFavIcon"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"
                                        />
                                    </svg>
                                </button>
                            </div>
                            <p
                                id="songAuthor"
                                class="text-gray-400 text-sm truncate"
                            >
                                -
                            </p>
                            <div
                                class="flex items-center gap-3 mt-1 text-xs text-gray-500"
                            >
                                <span
                                    id="songFormat"
                                    class="px-1.5 py-0.5 rounded bg-chip-purple/20 text-chip-purple"
                                    >-</span
                                >
                                <span id="songFrames">-</span>
                                <span
                                    id="songChannels"
                                    class="px-1.5 py-0.5 rounded bg-chip-cyan/20 text-chip-cyan hidden"
                                    >-</span
                                >
                                <select
                                    id="subsongSelect"
                                    class="hidden bg-gray-800 text-gray-300 text-xs rounded px-2 py-0.5 border border-gray-700 cursor-pointer hover:border-chip-purple/50 focus:outline-none focus:border-chip-purple"
                                >
                                    <!-- Populated dynamically -->
                                </select>
                            </div>
                        </div>
                        <div
                            id="envelopeShape"
                            class="font-mono text-xl text-chip-cyan"
                            title="Envelope Shape"
                        >
                            -
                        </div>
                    </div>

                    <!-- LMC1992 State (SNDH only) -->
                    <div
                        id="lmc1992Panel"
                        class="hidden mb-2 p-2 bg-gray-800/50 rounded text-xs"
                    >
                        <div class="flex items-center gap-4 flex-wrap">
                            <span class="text-gray-500 font-semibold"
                                >LMC1992</span
                            >
                            <span class="text-gray-400"
                                >Vol:
                                <span
                                    id="lmcMasterVol"
                                    class="text-white font-mono"
                                    >0</span
                                >dB</span
                            >
                            <span class="text-gray-400"
                                >L:
                                <span
                                    id="lmcLeftVol"
                                    class="text-white font-mono"
                                    >0</span
                                >dB</span
                            >
                            <span class="text-gray-400"
                                >R:
                                <span
                                    id="lmcRightVol"
                                    class="text-white font-mono"
                                    >0</span
                                >dB</span
                            >
                            <span class="text-gray-400"
                                >Bass:
                                <span
                                    id="lmcBass"
                                    class="text-chip-cyan font-mono"
                                    >0</span
                                >dB</span
                            >
                            <span class="text-gray-400"
                                >Treble:
                                <span
                                    id="lmcTreble"
                                    class="text-chip-purple font-mono"
                                    >0</span
                                >dB</span
                            >
                        </div>
                    </div>

                    <!-- Similar Tracks -->
                    <div id="similarPanel" class="hidden mb-2">
                        <div class="flex items-center gap-2 mb-1">
                            <span class="text-xs text-gray-500"
                                >Similar tracks by</span
                            >
                            <span
                                id="similarAuthor"
                                class="text-xs text-gray-400"
                                >-</span
                            >
                        </div>
                        <div
                            id="similarTracks"
                            class="flex gap-2 overflow-x-auto pb-1 scrollbar-thin scrollbar-thumb-gray-700"
                        >
                            <!-- Populated dynamically -->
                        </div>
                    </div>

                    <!-- Waveform Overview + Progress -->
                    <div class="mb-3">
                        <!-- Waveform scrubber (replaces progress bar when available) -->
                        <div
                            id="waveformScrubber"
                            class="relative h-16 rounded cursor-pointer hidden"
                            style="background: #1a1a2e"
                        >
                            <canvas
                                id="waveformOverview"
                                class="absolute inset-0 w-full h-full rounded"
                            ></canvas>
                            <!-- Time overlay -->
                            <div
                                class="absolute bottom-1 left-2 text-xs font-mono text-white/70 pointer-events-none z-10"
                                id="waveformCurrentTime"
                            >
                                0:00
                            </div>
                            <div
                                class="absolute bottom-1 right-2 text-xs font-mono text-white/70 pointer-events-none z-10"
                                id="waveformTotalTime"
                            >
                                0:00
                            </div>
                            <!-- Playhead -->
                            <div
                                id="waveformPlayhead"
                                class="absolute top-0 bottom-0 w-0.5 bg-white pointer-events-none z-20"
                                style="left: 0%"
                            ></div>
                            <!-- Loop markers -->
                            <div
                                id="waveformLoopA"
                                class="absolute top-0 bottom-0 w-0.5 bg-chip-cyan hidden pointer-events-none z-10"
                                style="left: 0%"
                            ></div>
                            <div
                                id="waveformLoopB"
                                class="absolute top-0 bottom-0 w-0.5 bg-chip-cyan hidden pointer-events-none z-10"
                                style="left: 100%"
                            ></div>
                            <div
                                id="waveformLoopRegion"
                                class="absolute top-0 bottom-0 bg-chip-cyan/20 hidden pointer-events-none"
                                style="left: 0%; width: 0%"
                            ></div>
                        </div>
                        <!-- Fallback progress bar (shown before waveform is ready) -->
                        <div
                            id="progressContainer"
                            class="flex items-center gap-2"
                        >
                            <span
                                id="currentTime"
                                class="text-xs font-mono text-gray-400 w-10 text-right"
                                >0:00</span
                            >
                            <div class="flex-1 relative">
                                <input
                                    type="range"
                                    id="progressBar"
                                    class="w-full"
                                    min="0"
                                    max="100"
                                    value="0"
                                    disabled
                                />
                                <!-- Loop markers overlay -->
                                <div
                                    id="loopMarkerA"
                                    class="absolute top-0 bottom-0 w-0.5 bg-chip-cyan hidden pointer-events-none"
                                    style="left: 0%"
                                ></div>
                                <div
                                    id="loopMarkerB"
                                    class="absolute top-0 bottom-0 w-0.5 bg-chip-cyan hidden pointer-events-none"
                                    style="left: 100%"
                                ></div>
                                <div
                                    id="loopRegion"
                                    class="absolute top-0 bottom-0 bg-chip-cyan/20 hidden pointer-events-none"
                                    style="left: 0%; width: 0%"
                                ></div>
                            </div>
                            <span
                                id="totalTime"
                                class="text-xs font-mono text-gray-400 w-10"
                                >0:00</span
                            >
                        </div>
                    </div>

                    <!-- Controls -->
                    <div
                        class="controls-row flex items-center justify-between flex-wrap gap-2"
                    >
                        <div class="flex items-center gap-2">
                            <button
                                id="restartBtn"
                                class="control-btn w-9 h-9 rounded-full bg-gray-800 hover:bg-gray-700 disabled:opacity-30 flex items-center justify-center"
                                disabled
                            >
                                <svg
                                    class="w-4 h-4"
                                    fill="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z" />
                                </svg>
                            </button>
                            <button
                                id="playBtn"
                                class="w-12 h-12 rounded-full bg-gradient-to-br from-chip-purple to-chip-cyan hover:opacity-90 disabled:opacity-30 flex items-center justify-center"
                                disabled
                            >
                                <svg
                                    id="playIcon"
                                    class="w-5 h-5 ml-0.5"
                                    fill="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path d="M8 5v14l11-7z" />
                                </svg>
                                <svg
                                    id="pauseIcon"
                                    class="w-5 h-5 hidden"
                                    fill="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                                </svg>
                            </button>
                            <button
                                id="stopBtn"
                                class="control-btn w-9 h-9 rounded-full bg-gray-800 hover:bg-gray-700 disabled:opacity-30 flex items-center justify-center"
                                disabled
                            >
                                <svg
                                    class="w-4 h-4"
                                    fill="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path d="M6 6h12v12H6z" />
                                </svg>
                            </button>
                            <button
                                id="nextBtn"
                                class="control-btn w-9 h-9 rounded-full bg-gray-800 hover:bg-gray-700 disabled:opacity-30 flex items-center justify-center"
                                disabled
                            >
                                <svg
                                    class="w-4 h-4"
                                    fill="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"
                                    />
                                </svg>
                            </button>
                            <button
                                id="shuffleBtn"
                                class="toggle-btn w-9 h-9 rounded-full bg-gray-800 hover:bg-gray-700 flex items-center justify-center"
                                title="Shuffle (S)"
                            >
                                <svg
                                    class="w-4 h-4"
                                    fill="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"
                                    />
                                </svg>
                            </button>
                            <button
                                id="autoPlayBtn"
                                class="toggle-btn w-9 h-9 rounded-full bg-gray-800 hover:bg-gray-700 flex items-center justify-center"
                                title="Auto-Play Next (N)"
                            >
                                <svg
                                    class="w-4 h-4"
                                    fill="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"
                                    />
                                </svg>
                            </button>
                        </div>

                        <!-- A-B Loop -->
                        <div class="flex items-center gap-1">
                            <button
                                id="loopABtn"
                                class="px-2 py-1 rounded text-xs bg-gray-800 hover:bg-gray-700 disabled:opacity-30"
                                disabled
                                title="Set Loop Start (A)"
                            >
                                A
                            </button>
                            <button
                                id="loopBBtn"
                                class="px-2 py-1 rounded text-xs bg-gray-800 hover:bg-gray-700 disabled:opacity-30"
                                disabled
                                title="Set Loop End (B)"
                            >
                                B
                            </button>
                            <button
                                id="loopClearBtn"
                                class="px-1.5 py-1 rounded text-xs bg-gray-800 hover:bg-gray-700 disabled:opacity-30 hidden"
                                title="Clear Loop"
                            >
                                âœ•
                            </button>
                            <span
                                id="loopIndicator"
                                class="text-xs text-chip-cyan hidden ml-1"
                            ></span>
                        </div>

                        <!-- Channel Mutes (dynamically populated) -->
                        <div
                            id="channelMutes"
                            class="flex items-center gap-1 flex-wrap"
                        >
                            <span class="text-xs text-gray-500 mr-1">CH:</span>
                            <!-- Channel buttons added by JS -->
                        </div>

                        <!-- Speed, Volume & Export -->
                        <div class="flex items-center gap-2">
                            <select
                                id="speedSelect"
                                class="bg-gray-800 text-xs rounded px-1 py-1 border-none outline-none cursor-pointer"
                                title="Playback Speed"
                            >
                                <option value="0.5">0.5x</option>
                                <option value="0.75">0.75x</option>
                                <option value="1" selected>1x</option>
                                <option value="1.25">1.25x</option>
                                <option value="1.5">1.5x</option>
                                <option value="2">2x</option>
                            </select>
                            <svg
                                class="w-3.5 h-3.5 text-gray-500"
                                fill="currentColor"
                                viewBox="0 0 24 24"
                            >
                                <path
                                    d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"
                                />
                            </svg>
                            <input
                                type="range"
                                id="volumeSlider"
                                class="w-20"
                                min="0"
                                max="100"
                                value="100"
                            />
                            <button
                                id="shareBtn"
                                class="p-1.5 rounded hover:bg-gray-800"
                                title="Share Link"
                            >
                                <svg
                                    class="w-4 h-4"
                                    fill="none"
                                    stroke="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        stroke-width="2"
                                        d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"
                                    />
                                </svg>
                            </button>
                            <button
                                id="exportBtn"
                                class="p-1.5 rounded hover:bg-gray-800"
                                title="Export WAV"
                            >
                                <svg
                                    class="w-4 h-4"
                                    fill="none"
                                    stroke="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        stroke-width="2"
                                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
                                    />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Visualization -->
                <div class="flex-1 p-4 overflow-auto">
                    <div class="flex items-center justify-between mb-3">
                        <h2 class="text-sm font-semibold text-gray-400">
                            Visualization
                        </h2>
                        <div class="flex gap-1">
                            <button
                                id="vizModeOsc"
                                class="px-2 py-1 rounded text-xs bg-chip-purple/20 text-chip-purple active"
                            >
                                Oscilloscope
                            </button>
                            <button
                                id="vizModeSpec"
                                class="px-2 py-1 rounded text-xs bg-gray-800 text-gray-400 hover:bg-gray-700"
                            >
                                Spectrum
                            </button>
                        </div>
                    </div>

                    <!-- Oscilloscope View (dynamically populated) -->
                    <div id="oscView">
                        <div id="oscChannels" class="grid gap-3 mb-3">
                            <!-- Channel oscilloscopes added by JS -->
                        </div>
                        <div class="relative">
                            <div
                                class="absolute top-1 left-2 text-xs font-mono text-gray-400 z-10"
                            >
                                MONO OUTPUT
                            </div>
                            <canvas
                                id="oscMono"
                                class="viz-canvas w-full h-28 bg-chip-darker rounded-lg"
                            ></canvas>
                        </div>
                    </div>

                    <!-- Spectrum View (dynamically populated) -->
                    <div id="specView" class="hidden">
                        <div id="specChannels" class="grid gap-3 mb-3">
                            <!-- Channel spectrums added by JS -->
                        </div>
                        <div class="relative">
                            <div
                                class="absolute top-1 left-2 text-xs font-mono text-gray-400 z-10"
                            >
                                COMBINED
                            </div>
                            <canvas
                                id="specCombined"
                                class="viz-canvas w-full h-28 bg-chip-darker rounded-lg"
                            ></canvas>
                        </div>
                    </div>
                </div>
            </section>
        </main>

        <!-- Toast Notification -->
        <div
            id="toast"
            class="fixed bottom-4 left-1/2 -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-lg shadow-lg transform transition-all duration-300 opacity-0 translate-y-4 pointer-events-none z-50"
        >
            <span id="toastMessage">Message</span>
        </div>

        <!-- Export Modal -->
        <div
            id="exportModal"
            class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4"
        >
            <div
                class="bg-chip-dark border border-gray-800 rounded-xl p-5 max-w-md w-full"
            >
                <h3 class="text-lg font-bold mb-4">Export to WAV</h3>
                <div class="space-y-3">
                    <div>
                        <label class="block text-sm text-gray-400 mb-1"
                            >Duration (seconds)</label
                        >
                        <input
                            type="number"
                            id="exportDuration"
                            value="180"
                            min="1"
                            max="600"
                            class="w-full bg-chip-darker border border-gray-700 rounded px-3 py-2 text-sm focus:outline-none focus:border-chip-purple/50"
                        />
                    </div>
                    <div>
                        <label class="block text-sm text-gray-400 mb-1"
                            >Export Mode</label
                        >
                        <select
                            id="exportMode"
                            class="w-full bg-chip-darker border border-gray-700 rounded px-3 py-2 text-sm focus:outline-none focus:border-chip-purple/50"
                        >
                            <option value="mixed">Mixed (all channels)</option>
                            <option value="stems">
                                Individual Stems (per channel)
                            </option>
                        </select>
                    </div>
                    <div id="exportStemOptions" class="hidden">
                        <label class="block text-sm text-gray-400 mb-1"
                            >Channels to export</label
                        >
                        <div
                            id="exportChannelCheckboxes"
                            class="flex flex-wrap gap-2"
                        >
                            <!-- Dynamically populated -->
                        </div>
                    </div>
                    <div class="text-xs text-gray-500">
                        Sample rate: 44100 Hz
                    </div>
                    <div id="exportProgress" class="hidden">
                        <div class="text-sm text-gray-400 mb-1">
                            Exporting...
                        </div>
                        <div
                            class="h-2 bg-gray-800 rounded-full overflow-hidden"
                        >
                            <div
                                id="exportProgressBar"
                                class="h-full bg-chip-purple transition-all"
                                style="width: 0%"
                            ></div>
                        </div>
                    </div>
                    <div class="flex justify-end gap-2 pt-2">
                        <button
                            id="exportCancel"
                            class="px-3 py-1.5 rounded bg-gray-800 hover:bg-gray-700 text-sm"
                        >
                            Cancel
                        </button>
                        <button
                            id="exportStart"
                            class="px-3 py-1.5 rounded bg-chip-purple hover:bg-chip-purple/80 text-sm"
                        >
                            Export
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Drop Zone -->
        <div
            id="dropZone"
            class="fixed inset-0 bg-chip-purple/20 backdrop-blur-sm z-50 hidden flex items-center justify-center"
        >
            <div class="text-center">
                <div class="text-5xl mb-3">ðŸ“</div>
                <div class="text-lg font-bold">Drop file to play</div>
                <div class="text-gray-400 text-sm">YM, SNDH, AY, AKS</div>
            </div>
        </div>

        <script type="module">
            // ============================================================================
            // Configuration
            // ============================================================================
            const SAMPLE_RATE = 44100;
            const BUFFER_SIZE = 4096;
            const WAVEFORM_SIZE = 256;
            const SPECTRUM_BINS = 32;
            const SPECTRUM_DECAY = 0.85;
            const SPECTRUM_BASE_FREQ = 32.703;
            const BINS_PER_OCTAVE = 4;
            const ROW_HEIGHT = 36;
            const BUFFER_ROWS = 10;

            const COLORS = {
                purple: "#8b5cf6",
                cyan: "#06b6d4",
                pink: "#ec4899",
                green: "#10b981",
                gridLight: "rgba(139, 92, 246, 0.05)",
            };

            // ============================================================================
            // State
            // ============================================================================
            let Ym2149Player = null;
            let catalog = null;
            let filteredTracks = [];
            let groupedTracks = []; // { type: 'author'|'track', ... }
            let currentTrackIndex = -1;
            let loadedFileData = null; // Stored file data for user-loaded files (for export)
            let loadedFileName = null; // Stored file name for user-loaded files
            let wasmPlayer = null;
            let audioContext = null;
            let scriptProcessor = null;
            let isPlaying = false;
            let animationId = null;
            let shuffleEnabled = false;
            let autoPlayEnabled = false;
            let playbackSpeed = 1.0;
            let loopA = null; // Loop start position (0-1)
            let loopB = null; // Loop end position (0-1)
            let waveformOverviewData = null; // Pre-rendered waveform peaks for scrubbing
            let currentCollection = "all";
            let searchQuery = "";
            let visibleStart = 0;
            let visibleEnd = 0;
            let collapsedAuthors = new Set(); // Set of "collection:author" keys
            let allCollapsed = true; // Start with all collapsed

            // Favorites & Stats (localStorage)
            const STORAGE_KEY_FAVORITES = "ym2149_favorites";
            const STORAGE_KEY_STATS = "ym2149_stats";
            const STORAGE_KEY_FINGERPRINTS = "ym2149_fingerprints";
            const STORAGE_KEY_PINNED = "ym2149_pinned_authors";
            let favorites = new Set(); // Set of track paths
            let playStats = {}; // { path: { playCount: N, lastPlayed: timestamp } }
            let audioFingerprints = {}; // { path: { avgAmp, lowFreq, midFreq, highFreq, noteDensity } }
            let pinnedAuthors = new Set(); // Set of "collection:author" keys

            function loadFavorites() {
                try {
                    const stored = localStorage.getItem(STORAGE_KEY_FAVORITES);
                    if (stored) favorites = new Set(JSON.parse(stored));
                } catch (e) {
                    console.warn("Failed to load favorites:", e);
                }
            }

            function saveFavorites() {
                try {
                    localStorage.setItem(
                        STORAGE_KEY_FAVORITES,
                        JSON.stringify([...favorites]),
                    );
                } catch (e) {
                    console.warn("Failed to save favorites:", e);
                }
            }

            function loadPinnedAuthors() {
                try {
                    const stored = localStorage.getItem(STORAGE_KEY_PINNED);
                    if (stored) pinnedAuthors = new Set(JSON.parse(stored));
                } catch (e) {
                    console.warn("Failed to load pinned authors:", e);
                }
            }

            function savePinnedAuthors() {
                try {
                    localStorage.setItem(
                        STORAGE_KEY_PINNED,
                        JSON.stringify([...pinnedAuthors]),
                    );
                } catch (e) {
                    console.warn("Failed to save pinned authors:", e);
                }
            }

            function isAuthorPinned(collection, author) {
                return pinnedAuthors.has(getAuthorKey(collection, author));
            }

            function togglePinAuthor(collection, author, event) {
                if (event) event.stopPropagation();
                const key = getAuthorKey(collection, author);
                if (pinnedAuthors.has(key)) {
                    pinnedAuthors.delete(key);
                } else {
                    pinnedAuthors.add(key);
                }
                savePinnedAuthors();
                rebuildGroupedTracks();
                renderTrackList();
            }

            function toggleFavorite(path, event) {
                if (event) event.stopPropagation();
                if (favorites.has(path)) {
                    favorites.delete(path);
                } else {
                    favorites.add(path);
                }
                saveFavorites();
                renderTrackList();
                updateFavoritesCount();
                updatePlayerFavoriteButton();
            }

            function updatePlayerFavoriteButton() {
                if (
                    currentTrackIndex < 0 ||
                    !filteredTracks[currentTrackIndex]
                ) {
                    elements.playerFavBtn.classList.add("hidden");
                    return;
                }
                const path = filteredTracks[currentTrackIndex].path;
                const isFav = favorites.has(path);
                elements.playerFavBtn.classList.remove("hidden");
                elements.playerFavBtn.classList.toggle("text-red-500", isFav);
                elements.playerFavBtn.classList.toggle("text-gray-600", !isFav);
                elements.playerFavIcon.setAttribute(
                    "fill",
                    isFav ? "currentColor" : "none",
                );
                elements.playerFavBtn.title = isFav
                    ? "Remove from favorites"
                    : "Add to favorites";
            }

            function isFavorite(path) {
                return favorites.has(path);
            }

            function loadPlayStats() {
                try {
                    const stored = localStorage.getItem(STORAGE_KEY_STATS);
                    if (stored) playStats = JSON.parse(stored);
                } catch (e) {
                    console.warn("Failed to load stats:", e);
                }
            }

            function savePlayStats() {
                try {
                    localStorage.setItem(
                        STORAGE_KEY_STATS,
                        JSON.stringify(playStats),
                    );
                } catch (e) {
                    console.warn("Failed to save stats:", e);
                }
            }

            function recordPlay(path) {
                if (!playStats[path]) {
                    playStats[path] = { playCount: 0, lastPlayed: 0 };
                }
                playStats[path].playCount++;
                playStats[path].lastPlayed = Date.now();
                savePlayStats();
            }

            function updateFavoritesCount() {
                const tab = document.querySelector(
                    '[data-collection="favorites"]',
                );
                if (tab) tab.textContent = `â™¥ (${favorites.size})`;
            }

            // ============================================================================
            // Catalog Caching (IndexedDB + gzip decompression)
            // ============================================================================
            const CATALOG_DB_NAME = "ym2149-catalog";
            const CATALOG_DB_VERSION = 1;
            const CATALOG_STORE = "catalog";

            async function openCatalogDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(
                        CATALOG_DB_NAME,
                        CATALOG_DB_VERSION,
                    );
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(CATALOG_STORE)) {
                            db.createObjectStore(CATALOG_STORE);
                        }
                    };
                });
            }

            async function getCachedCatalog() {
                try {
                    const db = await openCatalogDB();
                    return new Promise((resolve) => {
                        const tx = db.transaction(CATALOG_STORE, "readonly");
                        const store = tx.objectStore(CATALOG_STORE);
                        const request = store.get("data");
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => resolve(null);
                    });
                } catch {
                    return null;
                }
            }

            async function setCachedCatalog(data, etag) {
                try {
                    const db = await openCatalogDB();
                    const tx = db.transaction(CATALOG_STORE, "readwrite");
                    const store = tx.objectStore(CATALOG_STORE);
                    store.put(
                        { catalog: data, etag, timestamp: Date.now() },
                        "data",
                    );
                } catch (e) {
                    console.warn("Failed to cache catalog:", e);
                }
            }

            async function fetchAndDecompress(url) {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const etag =
                    response.headers.get("ETag") ||
                    response.headers.get("Last-Modified") ||
                    "";

                // Use DecompressionStream if available (modern browsers)
                if (
                    url.endsWith(".gz") &&
                    typeof DecompressionStream !== "undefined"
                ) {
                    const ds = new DecompressionStream("gzip");
                    const decompressed = response.body.pipeThrough(ds);
                    const text = await new Response(decompressed).text();
                    return { data: JSON.parse(text), etag };
                }

                return { data: await response.json(), etag };
            }

            async function loadCatalogCached() {
                // Try cache first
                const cached = await getCachedCatalog();

                // Try gzip version first, then fallbacks
                const urls = [
                    "catalog.json.gz",
                    "catalog.min.json",
                    "catalog.json",
                ];

                for (const url of urls) {
                    try {
                        // If cached and same ETag, use cache
                        const headResp = await fetch(url, {
                            method: "HEAD",
                        }).catch(() => null);
                        const serverEtag =
                            headResp?.headers.get("ETag") ||
                            headResp?.headers.get("Last-Modified") ||
                            "";

                        if (
                            cached &&
                            serverEtag &&
                            cached.etag === serverEtag
                        ) {
                            console.log("Using cached catalog");
                            return cached.catalog;
                        }

                        // Fetch fresh
                        console.log(`Loading catalog from ${url}...`);
                        const { data, etag } = await fetchAndDecompress(url);
                        await setCachedCatalog(
                            data,
                            etag || String(Date.now()),
                        );
                        console.log("Catalog loaded and cached");
                        return data;
                    } catch (e) {
                        console.warn(`Failed to load ${url}:`, e.message);
                        continue;
                    }
                }

                // Last resort: use cache even if potentially stale
                if (cached) {
                    console.log("Using stale cache as fallback");
                    return cached.catalog;
                }

                throw new Error("Failed to load catalog");
            }

            // Audio Fingerprints for content-based similarity
            // Fingerprint functions - use catalog data (track.fp) as primary source
            function loadFingerprints() {
                // No longer needed - fingerprints are in catalog
            }

            function saveFingerprints() {
                // No longer needed - fingerprints are in catalog
            }

            function saveFingerprint(path, fingerprint) {
                // No longer needed - fingerprints are pre-computed in catalog
            }

            function getFingerprint(trackOrPath) {
                // Get fingerprint from catalog track object
                if (typeof trackOrPath === "object" && trackOrPath.fp) {
                    return trackOrPath.fp;
                }
                // Lookup by path
                if (catalog) {
                    const track = catalog.tracks.find(
                        (t) => t.path === trackOrPath,
                    );
                    return track?.fp || null;
                }
                return null;
            }

            function calculateFingerprintDistance(fp1, fp2) {
                if (!fp1 || !fp2) return Infinity;

                // === Basic features ===
                const ampDiff =
                    Math.abs(fp1.amp - fp2.amp) /
                    Math.max(fp1.amp, fp2.amp, 0.001);
                const densityDiff =
                    Math.abs(fp1.density - fp2.density) /
                    Math.max(fp1.density, fp2.density, 1);
                const varianceDiff = Math.abs(
                    (fp1.variance || 0) - (fp2.variance || 0),
                );
                const punchDiff =
                    Math.abs((fp1.punch || 1) - (fp2.punch || 1)) / 10;
                const brightnessDiff = Math.abs(
                    (fp1.brightness || 0) - (fp2.brightness || 0),
                );

                // histogram: energy distribution (8 bins)
                let histDiff = 0;
                if (fp1.hist && fp2.hist) {
                    for (let i = 0; i < 8; i++) {
                        histDiff += Math.abs(
                            (fp1.hist[i] || 0) - (fp2.hist[i] || 0),
                        );
                    }
                    histDiff /= 8 * 255;
                }

                // sections: song structure (4 quarters)
                let sectionsDiff = 0;
                if (fp1.sections && fp2.sections) {
                    for (let i = 0; i < 4; i++) {
                        sectionsDiff += Math.abs(
                            (fp1.sections[i] || 0) - (fp2.sections[i] || 0),
                        );
                    }
                    sectionsDiff /= 4 * 255;
                }

                // tempo: BPM-like value
                let tempoDiff = 0;
                if (fp1.tempo && fp2.tempo) {
                    tempoDiff =
                        Math.abs(fp1.tempo - fp2.tempo) /
                        Math.max(fp1.tempo, fp2.tempo, 1);
                }

                // === New spectral features ===
                // Spectral centroid: center of mass of spectrum (0-1)
                let centroidDiff = 0;
                if (fp1.centroid !== undefined && fp2.centroid !== undefined) {
                    centroidDiff = Math.abs(fp1.centroid - fp2.centroid);
                }

                // Spectral flatness: tonal vs noise (0-1)
                let flatnessDiff = 0;
                if (fp1.flatness !== undefined && fp2.flatness !== undefined) {
                    flatnessDiff = Math.abs(fp1.flatness - fp2.flatness);
                }

                // Spectral bands: bass/low-mid/high-mid/treble energy (4 bins, 0-255)
                let bandsDiff = 0;
                if (fp1.bands && fp2.bands) {
                    for (let i = 0; i < 4; i++) {
                        bandsDiff += Math.abs(
                            (fp1.bands[i] || 0) - (fp2.bands[i] || 0),
                        );
                    }
                    bandsDiff /= 4 * 255;
                }

                // Chroma: pitch class histogram (12 bins, 0-255) - VERY important for melodic similarity
                let chromaDiff = 0;
                if (fp1.chroma && fp2.chroma) {
                    for (let i = 0; i < 12; i++) {
                        chromaDiff += Math.abs(
                            (fp1.chroma[i] || 0) - (fp2.chroma[i] || 0),
                        );
                    }
                    chromaDiff /= 12 * 255;
                }

                // === Rhythm features ===
                let rhythmRegDiff = 0;
                if (
                    fp1.rhythm_reg !== undefined &&
                    fp2.rhythm_reg !== undefined
                ) {
                    rhythmRegDiff = Math.abs(fp1.rhythm_reg - fp2.rhythm_reg);
                }

                let rhythmStrDiff = 0;
                if (
                    fp1.rhythm_str !== undefined &&
                    fp2.rhythm_str !== undefined
                ) {
                    rhythmStrDiff = Math.abs(fp1.rhythm_str - fp2.rhythm_str);
                }

                // === MFCCs - Industry standard for timbre similarity ===
                let mfccDiff = 0;
                if (
                    fp1.mfcc &&
                    fp2.mfcc &&
                    fp1.mfcc.length === 13 &&
                    fp2.mfcc.length === 13
                ) {
                    for (let i = 0; i < 13; i++) {
                        mfccDiff += Math.abs(
                            (fp1.mfcc[i] || 0) - (fp2.mfcc[i] || 0),
                        );
                    }
                    mfccDiff /= 13 * 255;
                }

                // MFCC Deltas - How timbre changes over time
                let mfccDeltaDiff = 0;
                if (
                    fp1.mfcc_d &&
                    fp2.mfcc_d &&
                    fp1.mfcc_d.length === 13 &&
                    fp2.mfcc_d.length === 13
                ) {
                    for (let i = 0; i < 13; i++) {
                        mfccDeltaDiff += Math.abs(
                            (fp1.mfcc_d[i] || 0) - (fp2.mfcc_d[i] || 0),
                        );
                    }
                    mfccDeltaDiff /= 13 * 255;
                }

                // MFCC Delta-Deltas - Acceleration of timbre changes
                let mfccDeltaDeltaDiff = 0;
                if (
                    fp1.mfcc_dd &&
                    fp2.mfcc_dd &&
                    fp1.mfcc_dd.length === 13 &&
                    fp2.mfcc_dd.length === 13
                ) {
                    for (let i = 0; i < 13; i++) {
                        mfccDeltaDeltaDiff += Math.abs(
                            (fp1.mfcc_dd[i] || 0) - (fp2.mfcc_dd[i] || 0),
                        );
                    }
                    mfccDeltaDeltaDiff /= 13 * 255;
                }

                // Chromagram - Melodic/harmonic progression over 8 time segments
                let chromagramDiff = 0;
                if (
                    fp1.chromagram &&
                    fp2.chromagram &&
                    fp1.chromagram.length === 96 &&
                    fp2.chromagram.length === 96
                ) {
                    for (let i = 0; i < 96; i++) {
                        chromagramDiff += Math.abs(
                            (fp1.chromagram[i] || 0) - (fp2.chromagram[i] || 0),
                        );
                    }
                    chromagramDiff /= 96 * 255;
                }

                // Weighted sum - comprehensive audio similarity
                // Total weights = 1.0
                return (
                    ampDiff * 0.01 + // Overall loudness
                    densityDiff * 0.01 + // Pitch content
                    varianceDiff * 0.01 + // Dynamic range
                    punchDiff * 0.01 + // Attack character
                    brightnessDiff * 0.02 + // Simple brightness
                    histDiff * 0.02 + // Energy distribution
                    sectionsDiff * 0.03 + // Song structure
                    tempoDiff * 0.05 + // Tempo/BPM
                    // Spectral features
                    centroidDiff * 0.02 + // Spectral brightness
                    flatnessDiff * 0.01 + // Tonal vs noise
                    bandsDiff * 0.03 + // EQ profile
                    chromaDiff * 0.08 + // Pitch classes (overall)
                    // Rhythm features
                    rhythmRegDiff * 0.03 + // Beat regularity
                    rhythmStrDiff * 0.05 + // Beat strength
                    // MFCCs - Timbre (most important)
                    mfccDiff * 0.2 + // Static timbre
                    mfccDeltaDiff * 0.1 + // Timbre dynamics
                    mfccDeltaDeltaDiff * 0.07 + // Timbre acceleration
                    // Chromagram - Melodic progression (very important)
                    chromagramDiff * 0.25
                ); // How melody evolves over time
            }

            function findSimilarByFingerprint(currentPath, maxResults = 10) {
                const currentTrack = catalog?.tracks.find(
                    (t) => t.path === currentPath,
                );
                const currentFp = currentTrack?.fp;
                if (!currentFp || !catalog) return [];

                const currentFormat = currentTrack.format;
                const currentAuthor = currentTrack.author?.toLowerCase();

                const scored = [];
                for (const track of catalog.tracks) {
                    if (track.path === currentPath) continue;
                    if (!track.fp) continue;
                    // Only compare within same format (SNDH vs SNDH, YM vs YM, etc.)
                    if (track.format !== currentFormat) continue;

                    let distance = calculateFingerprintDistance(
                        currentFp,
                        track.fp,
                    );

                    // Boost same-author tracks (reduce distance by 30%)
                    if (
                        currentAuthor &&
                        track.author?.toLowerCase() === currentAuthor
                    ) {
                        distance *= 0.7;
                    }

                    scored.push({ track, distance });
                }

                scored.sort((a, b) => a.distance - b.distance);
                return scored.slice(0, maxResults).map((s) => s.track);
            }

            // Visualization (dynamic arrays for multi-chip support)
            const MAX_CHANNELS = 12; // 4 PSG chips * 3 channels
            let channelWaveforms = [];
            let monoWaveform = new Float32Array(WAVEFORM_SIZE);
            let channelPhases = [];
            let channelSpectrums = [];
            let combinedSpectrum = new Float32Array(SPECTRUM_BINS);

            // Channel colors (cycles through for multi-chip)
            const CHANNEL_COLORS = [
                "#8b5cf6",
                "#06b6d4",
                "#ec4899", // PSG 1: purple, cyan, pink
                "#10b981",
                "#f59e0b",
                "#ef4444", // PSG 2: green, amber, red
                "#6366f1",
                "#14b8a6",
                "#f43f5e", // PSG 3: indigo, teal, rose
                "#8b5cf6",
                "#06b6d4",
                "#ec4899", // PSG 4: repeat
            ];
            const CHANNEL_NAMES = [
                "A",
                "B",
                "C",
                "D",
                "E",
                "F",
                "G",
                "H",
                "I",
                "J",
                "K",
                "L",
            ];
            // SNDH: 3 YM channels + 2 DAC channels (Left/Right)
            const SNDH_CHANNEL_NAMES = ["A", "B", "C", "L", "R"];
            const SNDH_CHANNEL_COLORS = [
                "#8b5cf6",
                "#06b6d4",
                "#ec4899", // YM: purple, cyan, pink
                "#10b981",
                "#ef4444", // DAC: green (L), red (R)
            ];

            // Get current format for channel naming
            let currentFormat = "";

            function getChannelName(index) {
                if (
                    currentFormat === "SNDH" &&
                    index < SNDH_CHANNEL_NAMES.length
                ) {
                    return SNDH_CHANNEL_NAMES[index];
                }
                return CHANNEL_NAMES[index] || `${index + 1}`;
            }

            function getChannelColor(index) {
                if (
                    currentFormat === "SNDH" &&
                    index < SNDH_CHANNEL_COLORS.length
                ) {
                    return SNDH_CHANNEL_COLORS[index];
                }
                return CHANNEL_COLORS[index % CHANNEL_COLORS.length];
            }

            // Amplitude history for SID visualization (stores last N amplitude values per channel)
            const AMPLITUDE_HISTORY_SIZE = 64;
            let amplitudeHistory = [];
            let sidModeDetected = []; // Track which channels are in SID mode

            // Note history for tracker-style scrolling display
            const NOTE_HISTORY_SIZE = 32; // Number of notes to keep in history
            const NOTE_SCROLL_SPEED = 0.5; // Pixels per frame
            let noteHistories = []; // Array of arrays, each containing {note, time, y} objects
            let noteScrollOffset = 0; // Global scroll position

            function initChannelArrays(count) {
                channelWaveforms = [];
                channelPhases = [];
                channelSpectrums = [];
                amplitudeHistory = [];
                sidModeDetected = [];
                noteHistories = [];
                for (let i = 0; i < count; i++) {
                    channelWaveforms.push(new Float32Array(WAVEFORM_SIZE));
                    channelPhases.push(0);
                    channelSpectrums.push(new Float32Array(SPECTRUM_BINS));
                    amplitudeHistory.push(
                        new Float32Array(AMPLITUDE_HISTORY_SIZE),
                    );
                    sidModeDetected.push(false);
                    noteHistories.push([]);
                }
                monoWaveform.fill(0);
                combinedSpectrum.fill(0);
                noteScrollOffset = 0;
                // Initialize per-channel sample buffers for real audio visualization
                initChannelSampleBuffers(count);
            }

            // ============================================================================
            // DOM Elements
            // ============================================================================
            const elements = {
                searchInput: document.getElementById("searchInput"),
                searchClear: document.getElementById("searchClear"),
                searchCount: document.getElementById("searchCount"),
                collectionTabs: document.getElementById("collectionTabs"),
                totalTracks: document.getElementById("totalTracks"),
                filteredCount: document.getElementById("filteredCount"),
                trackList: document.getElementById("trackList"),
                trackListInner: document.getElementById("trackListInner"),
                fileInput: document.getElementById("fileInput"),
                songTitle: document.getElementById("songTitle"),
                playerFavBtn: document.getElementById("playerFavBtn"),
                playerFavIcon: document.getElementById("playerFavIcon"),
                songAuthor: document.getElementById("songAuthor"),
                songFormat: document.getElementById("songFormat"),
                songFrames: document.getElementById("songFrames"),
                songChannels: document.getElementById("songChannels"),
                subsongSelect: document.getElementById("subsongSelect"),
                envelopeShape: document.getElementById("envelopeShape"),
                lmc1992Panel: document.getElementById("lmc1992Panel"),
                lmcMasterVol: document.getElementById("lmcMasterVol"),
                lmcLeftVol: document.getElementById("lmcLeftVol"),
                lmcRightVol: document.getElementById("lmcRightVol"),
                lmcBass: document.getElementById("lmcBass"),
                lmcTreble: document.getElementById("lmcTreble"),
                similarPanel: document.getElementById("similarPanel"),
                similarAuthor: document.getElementById("similarAuthor"),
                similarTracks: document.getElementById("similarTracks"),
                waveformScrubber: document.getElementById("waveformScrubber"),
                waveformOverview: document.getElementById("waveformOverview"),
                waveformPlayhead: document.getElementById("waveformPlayhead"),
                waveformCurrentTime: document.getElementById(
                    "waveformCurrentTime",
                ),
                waveformTotalTime: document.getElementById("waveformTotalTime"),
                waveformLoopA: document.getElementById("waveformLoopA"),
                waveformLoopB: document.getElementById("waveformLoopB"),
                waveformLoopRegion:
                    document.getElementById("waveformLoopRegion"),
                progressContainer: document.getElementById("progressContainer"),
                progressBar: document.getElementById("progressBar"),
                currentTime: document.getElementById("currentTime"),
                totalTime: document.getElementById("totalTime"),
                playBtn: document.getElementById("playBtn"),
                playIcon: document.getElementById("playIcon"),
                pauseIcon: document.getElementById("pauseIcon"),
                stopBtn: document.getElementById("stopBtn"),
                restartBtn: document.getElementById("restartBtn"),
                nextBtn: document.getElementById("nextBtn"),
                shuffleBtn: document.getElementById("shuffleBtn"),
                autoPlayBtn: document.getElementById("autoPlayBtn"),
                loopABtn: document.getElementById("loopABtn"),
                loopBBtn: document.getElementById("loopBBtn"),
                loopClearBtn: document.getElementById("loopClearBtn"),
                loopIndicator: document.getElementById("loopIndicator"),
                loopMarkerA: document.getElementById("loopMarkerA"),
                loopMarkerB: document.getElementById("loopMarkerB"),
                loopRegion: document.getElementById("loopRegion"),
                speedSelect: document.getElementById("speedSelect"),
                sidebar: document.getElementById("sidebar"),
                sidebarToggle: document.getElementById("sidebarToggle"),
                sidebarBackdrop: document.getElementById("sidebarBackdrop"),
                mobileMenuBtn: document.getElementById("mobileMenuBtn"),
                hideSidebarBtn: document.getElementById("hideSidebarBtn"),
                toast: document.getElementById("toast"),
                toastMessage: document.getElementById("toastMessage"),
                shareBtn: document.getElementById("shareBtn"),
                volumeSlider: document.getElementById("volumeSlider"),
                exportBtn: document.getElementById("exportBtn"),
                exportModal: document.getElementById("exportModal"),
                exportDuration: document.getElementById("exportDuration"),
                exportMode: document.getElementById("exportMode"),
                exportStemOptions: document.getElementById("exportStemOptions"),
                exportChannelCheckboxes: document.getElementById(
                    "exportChannelCheckboxes",
                ),
                exportSampleRate: document.getElementById("exportSampleRate"),
                exportProgress: document.getElementById("exportProgress"),
                exportProgressBar: document.getElementById("exportProgressBar"),
                exportCancel: document.getElementById("exportCancel"),
                exportStart: document.getElementById("exportStart"),
                dropZone: document.getElementById("dropZone"),
                vizModeOsc: document.getElementById("vizModeOsc"),
                vizModeSpec: document.getElementById("vizModeSpec"),
                oscView: document.getElementById("oscView"),
                specView: document.getElementById("specView"),
                oscChannels: document.getElementById("oscChannels"),
                specChannels: document.getElementById("specChannels"),
                channelMutes: document.getElementById("channelMutes"),
            };

            // Dynamic channel state
            let currentChannelCount = 3;
            const channelCanvases = { osc: [], spec: [] };
            const channelContexts = { osc: [], spec: [] };
            const channelNotes = [];
            const channelMuteButtons = [];

            const canvases = {
                oscMono: document.getElementById("oscMono"),
                specCombined: document.getElementById("specCombined"),
            };

            const contexts = {};

            // ============================================================================
            // Canvas Setup
            // ============================================================================
            function setupCanvas(canvas) {
                if (!canvas) return;
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                const ctx = canvas.getContext("2d");
                ctx.scale(dpr, dpr);
                return ctx;
            }

            function setupAllCanvases() {
                for (const [key, canvas] of Object.entries(canvases)) {
                    if (canvas) contexts[key] = setupCanvas(canvas);
                }
                // Setup dynamic channel canvases
                for (let i = 0; i < channelCanvases.osc.length; i++) {
                    channelContexts.osc[i] = setupCanvas(
                        channelCanvases.osc[i],
                    );
                    channelContexts.spec[i] = setupCanvas(
                        channelCanvases.spec[i],
                    );
                }
            }

            function setupChannelUI(count) {
                console.log(
                    "setupChannelUI called with count:",
                    count,
                    "current:",
                    currentChannelCount,
                    "canvases:",
                    channelCanvases.osc.length,
                );
                if (
                    count === currentChannelCount &&
                    channelCanvases.osc.length === count
                ) {
                    console.log("setupChannelUI: skipping, already set up");
                    return;
                }
                currentChannelCount = count;
                console.log(
                    "setupChannelUI: creating UI for",
                    count,
                    "channels",
                );

                // Initialize data arrays
                initChannelArrays(count);

                // Clear existing UI
                channelCanvases.osc = [];
                channelCanvases.spec = [];
                channelContexts.osc = [];
                channelContexts.spec = [];
                channelNotes.length = 0;
                channelMuteButtons.length = 0;

                // Determine grid columns based on channel count
                const cols = count <= 3 ? count : count <= 6 ? 3 : 4;

                // Create oscilloscope channels
                elements.oscChannels.innerHTML = "";
                elements.oscChannels.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
                for (let i = 0; i < count; i++) {
                    const color = getChannelColor(i);
                    const name = getChannelName(i);
                    const div = document.createElement("div");
                    div.className = "relative";
                    div.innerHTML = `
                        <div class="absolute top-1 left-2 text-xs font-mono z-10" style="color: ${color}99;">CH ${name}</div>
                        <div class="absolute top-1 right-2 text-xs font-mono text-gray-500 z-10" id="note${i}">---</div>
                        <canvas class="viz-canvas w-full h-20 bg-chip-darker rounded-lg" id="osc${i}"></canvas>
                    `;
                    elements.oscChannels.appendChild(div);
                    channelCanvases.osc.push(div.querySelector("canvas"));
                    channelNotes.push(div.querySelector(`#note${i}`));
                }

                // Create spectrum channels
                elements.specChannels.innerHTML = "";
                elements.specChannels.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
                for (let i = 0; i < count; i++) {
                    const color = getChannelColor(i);
                    const name = getChannelName(i);
                    const div = document.createElement("div");
                    div.className = "relative";
                    div.innerHTML = `
                        <div class="absolute top-1 left-2 text-xs font-mono z-10" style="color: ${color}99;">CH ${name}</div>
                        <canvas class="viz-canvas w-full h-20 bg-chip-darker rounded-lg" id="spec${i}"></canvas>
                    `;
                    elements.specChannels.appendChild(div);
                    channelCanvases.spec.push(div.querySelector("canvas"));
                }

                // Create channel mute buttons
                const existingLabel =
                    elements.channelMutes.querySelector("span");
                elements.channelMutes.innerHTML = "";
                if (existingLabel)
                    elements.channelMutes.appendChild(existingLabel);
                else {
                    const label = document.createElement("span");
                    label.className = "text-xs text-gray-500 mr-1";
                    label.textContent = "CH:";
                    elements.channelMutes.appendChild(label);
                }

                for (let i = 0; i < count; i++) {
                    const color = getChannelColor(i);
                    const name = getChannelName(i);
                    const btn = document.createElement("button");
                    btn.className =
                        "channel-btn px-2 py-1 text-xs font-mono rounded transition-all";
                    btn.dataset.channel = i;
                    btn.style.background = `${color}33`;
                    btn.style.color = color;
                    btn.textContent = name;
                    btn.addEventListener("click", () => {
                        if (!wasmPlayer) return;
                        const muted = wasmPlayer.isChannelMuted(i);
                        wasmPlayer.setChannelMute(i, !muted);
                        btn.style.opacity = muted ? "1" : "0.3";
                    });
                    elements.channelMutes.appendChild(btn);
                    channelMuteButtons.push(btn);
                }

                // Setup canvases
                requestAnimationFrame(setupAllCanvases);
            }

            // ============================================================================
            // Fuzzy Search
            // ============================================================================
            function fuzzyMatch(query, text) {
                if (!query) return { match: true, score: 0, indices: [] };
                query = query.toLowerCase();
                text = text.toLowerCase();

                let queryIdx = 0,
                    score = 0,
                    indices = [],
                    lastMatchIdx = -1;

                for (
                    let i = 0;
                    i < text.length && queryIdx < query.length;
                    i++
                ) {
                    if (text[i] === query[queryIdx]) {
                        indices.push(i);
                        if (lastMatchIdx === i - 1) score += 2;
                        else score += 1;
                        if (i === 0 || " _-".includes(text[i - 1])) score += 3;
                        lastMatchIdx = i;
                        queryIdx++;
                    }
                }

                return {
                    match: queryIdx === query.length,
                    score: queryIdx === query.length ? score : 0,
                    indices,
                };
            }

            function highlightMatches(text, indices) {
                if (!indices || !indices.length) return escapeHtml(text);
                let result = "",
                    lastIdx = 0;
                for (const idx of indices) {
                    result += escapeHtml(text.slice(lastIdx, idx));
                    result += `<span class="search-highlight">${escapeHtml(text[idx])}</span>`;
                    lastIdx = idx + 1;
                }
                result += escapeHtml(text.slice(lastIdx));
                return result;
            }

            function escapeHtml(text) {
                const div = document.createElement("div");
                div.textContent = text || "";
                return div.innerHTML;
            }

            // ============================================================================
            // Track Filtering & Grouping
            // ============================================================================
            function getAuthorKey(collection, author) {
                return `${collection}:${author}`;
            }

            function isAuthorCollapsed(collection, author) {
                return collapsedAuthors.has(getAuthorKey(collection, author));
            }

            function toggleAuthor(collection, author) {
                const key = getAuthorKey(collection, author);
                if (collapsedAuthors.has(key)) {
                    collapsedAuthors.delete(key);
                    allCollapsed = false;
                    updateCollapseButtonText();
                } else {
                    collapsedAuthors.add(key);
                }
                rebuildGroupedTracks();
                renderTrackList();
            }

            function updateCollapseButtonText() {
                const btn = document.getElementById("toggleCollapseBtn");
                if (btn) {
                    btn.textContent = allCollapsed
                        ? "Expand All"
                        : "Collapse All";
                }
            }

            function expandAllAuthors() {
                collapsedAuthors.clear();
                allCollapsed = false;
                rebuildGroupedTracks();
                renderTrackList();
            }

            function collapseAllAuthors() {
                // Add all current authors to collapsed set
                if (!catalog) return;
                for (const track of catalog.tracks) {
                    collapsedAuthors.add(
                        getAuthorKey(
                            track.collection,
                            track.author || "Unknown",
                        ),
                    );
                }
                allCollapsed = true;
                rebuildGroupedTracks();
                renderTrackList();
            }

            function filterAndGroupTracks() {
                if (!catalog) return;

                let tracks = catalog.tracks;

                // Filter by collection
                if (currentCollection === "favorites") {
                    tracks = tracks.filter((t) => favorites.has(t.path));
                } else if (currentCollection === "recent") {
                    // Get recently played tracks, sorted by lastPlayed descending, limit to 50
                    const recentPaths = Object.entries(playStats)
                        .filter(([, stats]) => stats.lastPlayed > 0)
                        .sort((a, b) => b[1].lastPlayed - a[1].lastPlayed)
                        .slice(0, 50)
                        .map(([path]) => path);
                    const pathSet = new Set(recentPaths);
                    tracks = recentPaths
                        .map((path) => tracks.find((t) => t.path === path))
                        .filter(Boolean);
                } else if (currentCollection !== "all") {
                    tracks = tracks.filter(
                        (t) => t.collection === currentCollection,
                    );
                }

                // Filter by search
                if (searchQuery) {
                    const results = [];
                    for (const track of tracks) {
                        const titleMatch = fuzzyMatch(
                            searchQuery,
                            track.title || "",
                        );
                        const authorMatch = fuzzyMatch(
                            searchQuery,
                            track.author || "",
                        );
                        if (titleMatch.match || authorMatch.match) {
                            results.push({
                                ...track,
                                searchScore: Math.max(
                                    titleMatch.score,
                                    authorMatch.score,
                                ),
                                titleIndices: titleMatch.indices,
                                authorIndices: authorMatch.indices,
                            });
                        }
                    }
                    results.sort((a, b) => b.searchScore - a.searchScore);
                    tracks = results;
                }

                filteredTracks = tracks;

                // Initialize all authors as collapsed on first load
                if (allCollapsed && collapsedAuthors.size === 0) {
                    for (const track of filteredTracks) {
                        collapsedAuthors.add(
                            getAuthorKey(
                                track.collection,
                                track.author || "Unknown",
                            ),
                        );
                    }
                }

                rebuildGroupedTracks();

                elements.searchCount.textContent = `${filteredTracks.length}`;
                elements.searchCount.classList.toggle("hidden", !searchQuery);
                elements.filteredCount.textContent = searchQuery
                    ? ""
                    : `${filteredTracks.length} shown`;

                renderTrackList();
            }

            function rebuildGroupedTracks() {
                groupedTracks = [];

                if (
                    searchQuery ||
                    currentCollection === "favorites" ||
                    currentCollection === "recent"
                ) {
                    // Flat list for search, favorites, and recent (no collapsing)
                    for (const track of filteredTracks) {
                        groupedTracks.push({
                            type: "track",
                            track,
                            index: filteredTracks.indexOf(track),
                        });
                    }
                } else {
                    // Group by collection -> author
                    const collections =
                        currentCollection === "all"
                            ? ["sndh", "ym", "ay", "arkos"]
                            : [currentCollection];

                    for (const colId of collections) {
                        const colTracks = filteredTracks.filter(
                            (t) => t.collection === colId,
                        );
                        if (colTracks.length === 0) continue;

                        // Group by author
                        const byAuthor = {};
                        for (const track of colTracks) {
                            const author = track.author || "Unknown";
                            if (!byAuthor[author]) byAuthor[author] = [];
                            byAuthor[author].push(track);
                        }

                        // Sort authors (pinned first, then alphabetically)
                        const authors = Object.keys(byAuthor).sort((a, b) => {
                            const aPinned = isAuthorPinned(colId, a);
                            const bPinned = isAuthorPinned(colId, b);
                            if (aPinned && !bPinned) return -1;
                            if (!aPinned && bPinned) return 1;
                            return a.localeCompare(b);
                        });

                        // Check if we need a separator (has both pinned and unpinned)
                        const hasPinned = authors.some((a) =>
                            isAuthorPinned(colId, a),
                        );
                        const hasUnpinned = authors.some(
                            (a) => !isAuthorPinned(colId, a),
                        );
                        const needsSeparator = hasPinned && hasUnpinned;
                        let separatorAdded = false;

                        for (const author of authors) {
                            const isCollapsed = isAuthorCollapsed(
                                colId,
                                author,
                            );
                            const isPinned = isAuthorPinned(colId, author);

                            // Add separator before first unpinned author
                            if (
                                needsSeparator &&
                                !isPinned &&
                                !separatorAdded
                            ) {
                                groupedTracks.push({
                                    type: "separator",
                                    collection: colId,
                                });
                                separatorAdded = true;
                            }

                            groupedTracks.push({
                                type: "author",
                                author,
                                collection: colId,
                                count: byAuthor[author].length,
                                collapsed: isCollapsed,
                                pinned: isPinned,
                            });

                            // Only add tracks if not collapsed
                            if (!isCollapsed) {
                                byAuthor[author].sort((a, b) =>
                                    (a.title || "").localeCompare(
                                        b.title || "",
                                    ),
                                );
                                for (const track of byAuthor[author]) {
                                    groupedTracks.push({
                                        type: "track",
                                        track,
                                        index: filteredTracks.indexOf(track),
                                    });
                                }
                            }
                        }
                    }
                }
            }

            // ============================================================================
            // Virtual Scroll Rendering
            // ============================================================================
            function renderTrackList() {
                const totalHeight = groupedTracks.length * ROW_HEIGHT;
                elements.trackListInner.style.height = `${totalHeight}px`;
                visibleStart = -1;
                visibleEnd = -1;
                updateVisibleRows();
            }

            function updateVisibleRows() {
                const scrollTop = elements.trackList.scrollTop;
                const containerHeight = elements.trackList.clientHeight;

                const start = Math.max(
                    0,
                    Math.floor(scrollTop / ROW_HEIGHT) - BUFFER_ROWS,
                );
                const end = Math.min(
                    groupedTracks.length,
                    Math.ceil((scrollTop + containerHeight) / ROW_HEIGHT) +
                        BUFFER_ROWS,
                );

                if (start === visibleStart && end === visibleEnd) return;
                visibleStart = start;
                visibleEnd = end;

                let html = "";
                for (let i = start; i < end; i++) {
                    const item = groupedTracks[i];

                    if (item.type === "separator") {
                        html += `
                            <div class="px-2 flex items-center"
                                 style="position: absolute; top: ${i * ROW_HEIGHT}px; left: 0; right: 0; height: ${ROW_HEIGHT}px;">
                                <div class="flex-1 h-px bg-gradient-to-r from-chip-cyan/50 via-chip-purple/30 to-transparent"></div>
                            </div>
                        `;
                    } else if (item.type === "author") {
                        const colLabel = item.collection.toUpperCase();
                        const chevronClass = item.collapsed ? "collapsed" : "";
                        const pinClass = item.pinned
                            ? "text-chip-cyan"
                            : "text-gray-600 hover:text-chip-cyan";
                        const pinFill = item.pinned ? "currentColor" : "none";
                        html += `
                            <div class="author-header px-2 py-1 text-xs font-medium text-gray-300"
                                 style="position: absolute; top: ${i * ROW_HEIGHT}px; left: 0; right: 0; height: ${ROW_HEIGHT}px; display: flex; align-items: center;"
                                 data-collection="${item.collection}" data-author="${escapeHtml(item.author)}">
                                <svg class="collapse-chevron w-3 h-3 mr-1 text-gray-500 ${chevronClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                                </svg>
                                <span class="text-chip-purple/60 mr-2">${colLabel}</span>
                                <span class="truncate flex-1">${escapeHtml(item.author)}</span>
                                <span class="text-gray-500 mr-2">${item.count}</span>
                                <button class="pin-btn ${pinClass} p-1 rounded hover:bg-gray-700/50 transition-colors" title="${item.pinned ? "Unpin author" : "Pin author"}">
                                    <svg class="w-3 h-3" fill="${pinFill}" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"/>
                                    </svg>
                                </button>
                            </div>
                        `;
                    } else {
                        const track = item.track;
                        const trackIdx = item.index;
                        const isActive = trackIdx === currentTrackIndex;
                        const isCurrentPlaying = isActive && isPlaying;
                        const isFav = isFavorite(track.path);

                        const titleHtml = track.titleIndices
                            ? highlightMatches(track.title, track.titleIndices)
                            : escapeHtml(track.title);

                        const channelBadge =
                            track.channels && track.channels > 3
                                ? `<span class="text-xs px-1 py-0.5 rounded bg-chip-purple/30 text-chip-purple ml-1">${track.channels}ch</span>`
                                : "";

                        const heartClass = isFav
                            ? "text-red-500"
                            : "text-gray-600 hover:text-red-400";
                        const heartFill = isFav ? "currentColor" : "none";

                        html += `
                            <div class="track-row flex items-center px-2 py-1 cursor-pointer ${isActive ? "active" : ""} ${isCurrentPlaying ? "playing" : ""}"
                                 style="position: absolute; top: ${i * ROW_HEIGHT}px; left: 0; right: 0; height: ${ROW_HEIGHT}px;"
                                 data-index="${trackIdx}" data-path="${escapeHtml(track.path)}">
                                <div class="w-5 text-center text-gray-500 text-xs shrink-0">${isCurrentPlaying ? "â–¶" : ""}</div>
                                <button class="fav-btn w-5 shrink-0 ${heartClass}" data-path="${escapeHtml(track.path)}">
                                    <svg class="w-3.5 h-3.5" fill="${heartFill}" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"/>
                                    </svg>
                                </button>
                                <div class="flex-1 min-w-0 px-1">
                                    <div class="truncate text-sm">${titleHtml}</div>
                                </div>
                                <div class="text-right flex items-center justify-end gap-1">
                                    <span class="text-xs px-1 py-0.5 rounded bg-gray-800/50 text-gray-500">${track.format}</span>${channelBadge}
                                </div>
                            </div>
                        `;
                    }
                }
                elements.trackListInner.innerHTML = html;

                // Click handlers for tracks
                elements.trackListInner
                    .querySelectorAll(".track-row")
                    .forEach((row) => {
                        row.addEventListener("click", (e) => {
                            // Don't play if clicking on favorite button
                            if (e.target.closest(".fav-btn")) return;
                            playTrack(parseInt(row.dataset.index));
                        });
                    });

                // Click handlers for favorite buttons
                elements.trackListInner
                    .querySelectorAll(".fav-btn")
                    .forEach((btn) => {
                        btn.addEventListener("click", (e) => {
                            e.stopPropagation();
                            toggleFavorite(btn.dataset.path, e);
                        });
                    });

                // Click handlers for pin buttons
                elements.trackListInner
                    .querySelectorAll(".pin-btn")
                    .forEach((btn) => {
                        btn.addEventListener("click", (e) => {
                            e.stopPropagation();
                            const header = btn.closest(".author-header");
                            if (header) {
                                togglePinAuthor(
                                    header.dataset.collection,
                                    header.dataset.author,
                                    e,
                                );
                            }
                        });
                    });

                // Click handlers for author headers (toggle collapse)
                elements.trackListInner
                    .querySelectorAll(".author-header")
                    .forEach((header) => {
                        header.addEventListener("click", () => {
                            const col = header.dataset.collection;
                            const author = header.dataset.author;
                            toggleAuthor(col, author);
                        });
                    });
            }

            // ============================================================================
            // Collection Tabs
            // ============================================================================
            function getRecentlyPlayedCount() {
                return Object.keys(playStats).filter(
                    (path) => playStats[path].lastPlayed > 0,
                ).length;
            }

            function renderCollections() {
                if (!catalog) return;

                let html = `<button class="collection-tab px-2 py-1 rounded text-xs border border-transparent ${currentCollection === "all" ? "active" : "hover:bg-gray-800"}" data-collection="all">All</button>`;

                // Favorites tab
                html += `<button class="collection-tab px-2 py-1 rounded text-xs border border-transparent ${currentCollection === "favorites" ? "active" : "hover:bg-gray-800"}" data-collection="favorites">â™¥ (${favorites.size})</button>`;

                // Recently Played tab
                const recentCount = getRecentlyPlayedCount();
                html += `<button class="collection-tab px-2 py-1 rounded text-xs border border-transparent ${currentCollection === "recent" ? "active" : "hover:bg-gray-800"}" data-collection="recent">â± Recent (${recentCount})</button>`;

                for (const col of catalog.collections) {
                    if (col.trackCount === 0) continue;
                    html += `<button class="collection-tab px-2 py-1 rounded text-xs border border-transparent ${currentCollection === col.id ? "active" : "hover:bg-gray-800"}" data-collection="${col.id}">${col.format} (${col.trackCount})</button>`;
                }

                elements.collectionTabs.innerHTML = html;
                elements.totalTracks.textContent =
                    catalog.tracks.length.toLocaleString();

                elements.collectionTabs
                    .querySelectorAll(".collection-tab")
                    .forEach((tab) => {
                        tab.addEventListener("click", () => {
                            currentCollection = tab.dataset.collection;
                            renderCollections();
                            filterAndGroupTracks();
                        });
                    });
            }

            // ============================================================================
            // Audio
            // ============================================================================
            let audioUnlocked = false;
            async function ensureAudioContext() {
                if (!audioContext) {
                    audioContext = new (
                        window.AudioContext || window.webkitAudioContext
                    )({ sampleRate: SAMPLE_RATE });
                }
                if (audioContext.state === "suspended") {
                    await audioContext.resume();
                }
                // iOS Safari needs a silent buffer played to fully unlock audio
                if (!audioUnlocked && audioContext.state === "running") {
                    const silentBuffer = audioContext.createBuffer(
                        1,
                        1,
                        SAMPLE_RATE,
                    );
                    const source = audioContext.createBufferSource();
                    source.buffer = silentBuffer;
                    source.connect(audioContext.destination);
                    source.start(0);
                    audioUnlocked = true;
                }
            }

            let speedResampleBuffer = new Float32Array(0);
            let speedResamplePos = 0;
            let mediaStreamDest = null;
            let audioElement = null;

            // Audio sample buffer for real waveform visualization
            const AUDIO_VIS_BUFFER_SIZE = 2048; // Larger buffer for smoother visualization
            let audioSampleBuffer = new Float32Array(AUDIO_VIS_BUFFER_SIZE);
            let audioSampleWritePos = 0;

            // Per-channel audio sample buffers for per-channel oscilloscope
            let channelSampleBuffers = []; // Array of Float32Array, one per channel
            let channelSampleWritePos = 0;

            function initChannelSampleBuffers(count) {
                channelSampleBuffers = [];
                for (let i = 0; i < count; i++) {
                    channelSampleBuffers.push(
                        new Float32Array(AUDIO_VIS_BUFFER_SIZE),
                    );
                }
                channelSampleWritePos = 0;
                currentChannelCount = count;
            }

            function startAudioProcessing() {
                if (scriptProcessor) return;

                scriptProcessor = audioContext.createScriptProcessor(
                    BUFFER_SIZE,
                    1,
                    1,
                );
                scriptProcessor.onaudioprocess = (e) => {
                    const output = e.outputBuffer.getChannelData(0);
                    if (!isPlaying || !wasmPlayer) {
                        output.fill(0);
                        return;
                    }

                    // For playback speed, we generate more/fewer samples and resample
                    const neededSamples = Math.ceil(
                        output.length * playbackSpeed,
                    );

                    // Ensure we have enough samples in the buffer
                    while (
                        speedResampleBuffer.length - speedResamplePos <
                        neededSamples
                    ) {
                        // Use generateSamplesWithChannels to get both mono and per-channel outputs
                        const result =
                            wasmPlayer.generateSamplesWithChannels(BUFFER_SIZE);
                        const newSamples = result.mono;
                        const channelData = result.channels;
                        const chCount = result.channelCount;

                        // Initialize per-channel buffers if needed
                        if (channelSampleBuffers.length !== chCount) {
                            initChannelSampleBuffers(chCount);
                        }

                        // Copy all samples to visualization ring buffers
                        for (let i = 0; i < newSamples.length; i++) {
                            // Mono buffer
                            audioSampleBuffer[audioSampleWritePos] =
                                newSamples[i];

                            // Per-channel buffers
                            for (let ch = 0; ch < chCount; ch++) {
                                channelSampleBuffers[ch][
                                    channelSampleWritePos
                                ] = channelData[i * chCount + ch];
                            }

                            audioSampleWritePos =
                                (audioSampleWritePos + 1) %
                                AUDIO_VIS_BUFFER_SIZE;
                            channelSampleWritePos =
                                (channelSampleWritePos + 1) %
                                AUDIO_VIS_BUFFER_SIZE;
                        }

                        const newBuffer = new Float32Array(
                            speedResampleBuffer.length -
                                speedResamplePos +
                                newSamples.length,
                        );
                        newBuffer.set(
                            speedResampleBuffer.subarray(speedResamplePos),
                        );
                        newBuffer.set(
                            newSamples,
                            speedResampleBuffer.length - speedResamplePos,
                        );
                        speedResampleBuffer = newBuffer;
                        speedResamplePos = 0;
                    }

                    // Resample to output
                    for (let i = 0; i < output.length; i++) {
                        const srcPos = speedResamplePos + i * playbackSpeed;
                        const srcIdx = Math.floor(srcPos);
                        const frac = srcPos - srcIdx;
                        if (srcIdx + 1 < speedResampleBuffer.length) {
                            // Linear interpolation
                            output[i] =
                                speedResampleBuffer[srcIdx] * (1 - frac) +
                                speedResampleBuffer[srcIdx + 1] * frac;
                        } else {
                            output[i] = speedResampleBuffer[srcIdx] || 0;
                        }
                    }
                    speedResamplePos += Math.floor(
                        output.length * playbackSpeed,
                    );

                    // Trim buffer if it gets too large
                    if (speedResamplePos > BUFFER_SIZE * 4) {
                        speedResampleBuffer =
                            speedResampleBuffer.subarray(speedResamplePos);
                        speedResamplePos = 0;
                    }
                };

                // MediaStream approach for iOS/mobile
                try {
                    mediaStreamDest =
                        audioContext.createMediaStreamDestination();
                    scriptProcessor.connect(mediaStreamDest);
                    audioElement = new Audio();
                    audioElement.srcObject = mediaStreamDest.stream;
                    audioElement.play().catch(() => {
                        // Fallback to direct connection if MediaStream fails
                        scriptProcessor.disconnect();
                        scriptProcessor.connect(audioContext.destination);
                    });
                } catch (e) {
                    // Fallback for browsers without MediaStream support
                    scriptProcessor.connect(audioContext.destination);
                }
            }

            function stopAudioProcessing() {
                // Reset speed resample buffer
                speedResampleBuffer = new Float32Array(0);
                speedResamplePos = 0;

                if (scriptProcessor) {
                    scriptProcessor.disconnect();
                    scriptProcessor = null;
                }
                if (audioElement) {
                    audioElement.pause();
                    audioElement.srcObject = null;
                    audioElement = null;
                }
                mediaStreamDest = null;
            }

            // ============================================================================
            // Playback
            // ============================================================================
            async function loadTrack(path) {
                const response = await fetch(path);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return new Uint8Array(await response.arrayBuffer());
            }

            async function playTrack(index) {
                if (index < 0 || index >= filteredTracks.length) return;
                closeSidebarOnMobile();

                const track = filteredTracks[index];
                currentTrackIndex = index;
                loadedFileData = null; // Clear user-loaded file data
                loadedFileName = null;

                // Record play for statistics
                recordPlay(track.path);

                // Clear previous waveform, show fallback progress bar
                waveformOverviewData = null;
                elements.waveformScrubber.classList.add("hidden");
                elements.progressContainer.classList.remove("hidden");

                try {
                    // Load track data first (doesn't require user interaction)
                    const data = await loadTrack(track.path);
                    wasmPlayer = new Ym2149Player(data);
                    wasmPlayer.set_volume(elements.volumeSlider.value / 100);

                    // Set format for channel naming before setting up UI
                    currentFormat =
                        wasmPlayer.metadata.format || track.format || "";

                    // Setup channel UI for multi-chip support
                    const channelCount = wasmPlayer.channelCount
                        ? wasmPlayer.channelCount()
                        : 3;
                    setupChannelUI(channelCount);

                    // Clear all oscilloscope waveforms after channel setup
                    clearAllWaveforms();
                    drawAllVisualization(); // Force immediate redraw with zeroed waveforms

                    updateMetadataUI(track);
                    enableControls();
                    resetVisualization();
                    updateLmc1992Display(); // Show LMC1992 panel for SNDH
                    updateVisibleRows();

                    // Use pre-rendered waveform from catalog if available
                    if (track.w) {
                        loadPrerenderedWaveform(track.w);
                    } else {
                        // Fall back to progress bar for tracks without waveform data
                        elements.waveformScrubber.classList.add("hidden");
                        elements.progressContainer.classList.remove("hidden");
                    }

                    // Try to start audio (may fail due to autoplay policy)
                    try {
                        await ensureAudioContext();
                        wasmPlayer.play();
                        isPlaying = true;
                        startAudioProcessing();
                        startVisualization();
                        updatePlayButton();
                    } catch (audioErr) {
                        console.warn(
                            "Audio autoplay blocked, click play to start:",
                            audioErr,
                        );
                        // UI is ready, user can click play
                        isPlaying = false;
                        updatePlayButton();
                    }
                } catch (err) {
                    console.error("Playback error:", err);
                    elements.songTitle.textContent = "Error loading";
                    elements.songAuthor.textContent = err.message;
                }
            }

            function updateMetadataUI(track) {
                if (!wasmPlayer) return;
                const meta = wasmPlayer.metadata;
                const channelCount = wasmPlayer.channelCount
                    ? wasmPlayer.channelCount()
                    : 3;
                elements.songTitle.textContent =
                    track?.title || meta.title || "Unknown";
                elements.songAuthor.textContent =
                    track?.author || meta.author || "Unknown";
                elements.songFormat.textContent =
                    track?.format || meta.format || "-";
                elements.songFrames.textContent = `${meta.frame_count} frames`;
                // Show channel count if more than 3
                if (channelCount > 3) {
                    elements.songChannels.textContent = `${channelCount} channels`;
                    elements.songChannels.classList.remove("hidden");
                } else {
                    elements.songChannels.classList.add("hidden");
                }
                // Show subsong selector if more than 1 subsong
                updateSubsongSelector();
                elements.totalTime.textContent = formatTime(
                    meta.duration_seconds,
                );
                elements.progressBar.value = 0;
                elements.currentTime.textContent = "0:00";
                updatePlayerFavoriteButton();
                updateSimilarTracks(track);
            }

            function updateSubsongSelector() {
                if (!wasmPlayer) {
                    elements.subsongSelect.classList.add("hidden");
                    return;
                }

                const subsongCount = wasmPlayer.subsongCount
                    ? wasmPlayer.subsongCount()
                    : 1;
                const currentSubsong = wasmPlayer.currentSubsong
                    ? wasmPlayer.currentSubsong()
                    : 1;

                if (subsongCount <= 1) {
                    elements.subsongSelect.classList.add("hidden");
                    return;
                }

                // Populate dropdown
                let html = "";
                for (let i = 1; i <= subsongCount; i++) {
                    html += `<option value="${i}" ${i === currentSubsong ? "selected" : ""}>Track ${i}/${subsongCount}</option>`;
                }
                elements.subsongSelect.innerHTML = html;
                elements.subsongSelect.classList.remove("hidden");
            }

            function changeSubsong(index) {
                if (!wasmPlayer || !wasmPlayer.setSubsong) return;

                const wasPlaying = isPlaying;
                if (wasPlaying) {
                    wasmPlayer.pause();
                }

                const success = wasmPlayer.setSubsong(index);
                if (success) {
                    // Update metadata (duration may change per subsong)
                    const meta = wasmPlayer.metadata;
                    elements.totalTime.textContent = formatTime(
                        meta.duration_seconds,
                    );
                    elements.progressBar.value = 0;
                    elements.currentTime.textContent = "0:00";
                    showToast(`Track ${index}`);
                }

                if (wasPlaying) {
                    wasmPlayer.play();
                }
            }

            function updateSimilarTracks(currentTrack) {
                if (!catalog || !currentTrack) {
                    elements.similarPanel.classList.add("hidden");
                    return;
                }

                const author = currentTrack.author;
                const format = currentTrack.format;

                // Calculate how many similar tracks to show based on screen width
                // Each track button is ~160px wide (150px + gap)
                const containerWidth =
                    elements.similarTracks.parentElement?.offsetWidth ||
                    window.innerWidth;
                const trackButtonWidth = 160;
                const headerWidth = 120; // "Similar tracks by" label
                const availableWidth = containerWidth - headerWidth;
                const maxTracks = Math.max(
                    2,
                    Math.min(8, Math.floor(availableWidth / trackButtonWidth)),
                );

                let similar = [];
                let similarityMode = "metadata"; // 'metadata' or 'audio'

                // Try fingerprint-based similarity first (from catalog)
                if (currentTrack.fp) {
                    const fpSimilar = findSimilarByFingerprint(
                        currentTrack.path,
                        maxTracks + 2,
                    );
                    if (fpSimilar.length >= 2) {
                        similar = fpSimilar;
                        similarityMode = "audio";
                    }
                }

                // Fallback to metadata-based similarity
                if (similar.length < 2) {
                    similar = catalog.tracks.filter(
                        (t) =>
                            t.path !== currentTrack.path &&
                            (t.author === author || t.format === format),
                    );

                    // Prioritize same author, then same format
                    similar.sort((a, b) => {
                        const aScore =
                            (a.author === author ? 2 : 0) +
                            (a.format === format ? 1 : 0);
                        const bScore =
                            (b.author === author ? 2 : 0) +
                            (b.format === format ? 1 : 0);
                        return bScore - aScore;
                    });
                    similarityMode = "metadata";
                }

                // Limit to calculated max tracks (minimum 2)
                similar = similar.slice(0, maxTracks);

                if (similar.length < 2) {
                    elements.similarPanel.classList.add("hidden");
                    return;
                }

                // Update label based on similarity mode
                if (similarityMode === "audio") {
                    elements.similarAuthor.textContent = "ðŸŽµ similar sound";
                } else {
                    elements.similarAuthor.textContent =
                        author || "similar artists";
                }
                elements.similarPanel.classList.remove("hidden");

                // Generate similar tracks HTML
                let html = "";
                for (const track of similar) {
                    const isSameAuthor = track.author === author;
                    html += `
                        <button class="similar-track shrink-0 px-2 py-1 bg-gray-800 hover:bg-gray-700 rounded text-xs text-left max-w-[150px] truncate"
                                data-path="${escapeHtml(track.path)}" title="${escapeHtml(track.title)} by ${escapeHtml(track.author || "Unknown")}">
                            <div class="truncate ${isSameAuthor ? "text-white" : "text-gray-300"}">${escapeHtml(track.title)}</div>
                            ${!isSameAuthor ? `<div class="truncate text-gray-500 text-[10px]">${escapeHtml(track.author || "Unknown")}</div>` : ""}
                        </button>`;
                }
                elements.similarTracks.innerHTML = html;

                // Add click handlers
                elements.similarTracks
                    .querySelectorAll(".similar-track")
                    .forEach((btn) => {
                        btn.addEventListener("click", () => {
                            const path = btn.dataset.path;
                            const idx = catalog.tracks.findIndex(
                                (t) => t.path === path,
                            );
                            if (idx >= 0) {
                                // Update filtered tracks to include all so we can find the track
                                const origCollection = currentCollection;
                                const origFiltered = filteredTracks;
                                filteredTracks = catalog.tracks;
                                playTrack(idx);
                                filteredTracks = origFiltered;
                            }
                        });
                    });
            }

            function enableControls() {
                elements.playBtn.disabled = false;
                elements.stopBtn.disabled = false;
                elements.restartBtn.disabled = false;
                elements.nextBtn.disabled = false;
                elements.progressBar.disabled = false;
                elements.loopABtn.disabled = false;
                elements.loopBBtn.disabled = false;
                // Clear any previous loop when loading a new track
                clearLoop();
            }

            async function togglePlayPause() {
                if (!wasmPlayer) return;
                if (isPlaying) {
                    wasmPlayer.pause();
                    isPlaying = false;
                    // Don't stop visualization - let decay effect work
                } else {
                    // Ensure AudioContext is created and resumed (requires user interaction)
                    await ensureAudioContext();
                    wasmPlayer.play();
                    isPlaying = true;
                    startAudioProcessing();
                    startVisualization();
                }
                updatePlayButton();
                updateVisibleRows();
            }

            function stop() {
                if (!wasmPlayer) return;
                wasmPlayer.stop();
                isPlaying = false;
                stopAudioProcessing();
                // Don't stop visualization - let it keep running for decay effect
                // stopVisualization();
                updatePlayButton();
                elements.progressBar.value = 0;
                elements.currentTime.textContent = "0:00";
                resetVisualization();
                updateVisibleRows();
            }

            function restart() {
                if (!wasmPlayer) return;
                const wasPlaying = isPlaying;
                stop();
                if (wasPlaying) {
                    wasmPlayer.play();
                    isPlaying = true;
                    startAudioProcessing();
                    startVisualization();
                    updatePlayButton();
                }
            }

            function playNext() {
                if (shuffleEnabled) {
                    playRandomTrack();
                } else if (currentTrackIndex < filteredTracks.length - 1) {
                    playTrack(currentTrackIndex + 1);
                }
            }

            function playRandomTrack() {
                if (filteredTracks.length <= 1) return;
                let randomIndex;
                do {
                    randomIndex = Math.floor(
                        Math.random() * filteredTracks.length,
                    );
                } while (randomIndex === currentTrackIndex);
                playTrack(randomIndex);
            }

            function toggleShuffle() {
                shuffleEnabled = !shuffleEnabled;
                elements.shuffleBtn.classList.toggle(
                    "bg-chip-purple",
                    shuffleEnabled,
                );
                elements.shuffleBtn.classList.toggle(
                    "text-white",
                    shuffleEnabled,
                );
                elements.shuffleBtn.classList.toggle(
                    "bg-gray-800",
                    !shuffleEnabled,
                );
                elements.shuffleBtn.classList.toggle("active", shuffleEnabled);
                showToast(shuffleEnabled ? "Shuffle ON" : "Shuffle OFF");
            }

            function toggleAutoPlay() {
                autoPlayEnabled = !autoPlayEnabled;
                elements.autoPlayBtn.classList.toggle(
                    "bg-chip-purple",
                    autoPlayEnabled,
                );
                elements.autoPlayBtn.classList.toggle(
                    "text-white",
                    autoPlayEnabled,
                );
                elements.autoPlayBtn.classList.toggle(
                    "bg-gray-800",
                    !autoPlayEnabled,
                );
                elements.autoPlayBtn.classList.toggle(
                    "active",
                    autoPlayEnabled,
                );
                showToast(autoPlayEnabled ? "Auto-Play ON" : "Auto-Play OFF");
            }

            // A-B Loop functions
            function setLoopA() {
                if (!wasmPlayer) return;
                loopA = wasmPlayer.position_percentage();
                updateLoopUI();
            }

            function setLoopB() {
                if (!wasmPlayer) return;
                loopB = wasmPlayer.position_percentage();
                // Ensure A < B
                if (loopA !== null && loopB < loopA) {
                    [loopA, loopB] = [loopB, loopA];
                }
                updateLoopUI();
            }

            function clearLoop() {
                loopA = null;
                loopB = null;
                updateLoopUI();
            }

            function updateLoopUI() {
                const hasLoop = loopA !== null && loopB !== null;
                elements.loopABtn.classList.toggle(
                    "bg-chip-cyan",
                    loopA !== null,
                );
                elements.loopABtn.classList.toggle(
                    "text-black",
                    loopA !== null,
                );
                elements.loopABtn.classList.toggle("active", loopA !== null);
                elements.loopBBtn.classList.toggle(
                    "bg-chip-cyan",
                    loopB !== null,
                );
                elements.loopBBtn.classList.toggle(
                    "text-black",
                    loopB !== null,
                );
                elements.loopBBtn.classList.toggle("active", loopB !== null);
                elements.loopClearBtn.classList.toggle("hidden", !hasLoop);

                // Update progress bar markers
                if (loopA !== null) {
                    elements.loopMarkerA.style.left = `${loopA * 100}%`;
                    elements.loopMarkerA.classList.remove("hidden");
                } else {
                    elements.loopMarkerA.classList.add("hidden");
                }

                if (loopB !== null) {
                    elements.loopMarkerB.style.left = `${loopB * 100}%`;
                    elements.loopMarkerB.classList.remove("hidden");
                } else {
                    elements.loopMarkerB.classList.add("hidden");
                }

                if (hasLoop) {
                    const duration =
                        wasmPlayer?.metadata?.duration_seconds || 0;
                    const startTime = formatTime(loopA * duration);
                    const endTime = formatTime(loopB * duration);
                    elements.loopIndicator.textContent = `${startTime}-${endTime}`;
                    elements.loopIndicator.classList.remove("hidden");
                    // Show loop region
                    elements.loopRegion.style.left = `${loopA * 100}%`;
                    elements.loopRegion.style.width = `${(loopB - loopA) * 100}%`;
                    elements.loopRegion.classList.remove("hidden");
                } else {
                    elements.loopIndicator.classList.add("hidden");
                    elements.loopRegion.classList.add("hidden");
                }

                // Update waveform loop markers too
                updateWaveformLoopMarkers();
            }

            function checkLoopBoundary() {
                if (!wasmPlayer || loopA === null || loopB === null) return;
                const position = wasmPlayer.position_percentage();
                if (position >= loopB) {
                    wasmPlayer.seek_to_percentage(loopA);
                }
            }

            // Playback speed
            function setPlaybackSpeed(speed) {
                playbackSpeed = speed;
                if (audioContext) {
                    // Adjust playback rate by changing how fast we consume samples
                    // This is handled in the audio processing
                }
            }

            // Toast notification
            let toastTimeout = null;
            function showToast(message, duration = 2000) {
                elements.toastMessage.textContent = message;
                elements.toast.classList.remove("opacity-0", "translate-y-4");
                elements.toast.classList.add("opacity-100", "translate-y-0");

                if (toastTimeout) clearTimeout(toastTimeout);
                toastTimeout = setTimeout(() => {
                    elements.toast.classList.add("opacity-0", "translate-y-4");
                    elements.toast.classList.remove(
                        "opacity-100",
                        "translate-y-0",
                    );
                }, duration);
            }

            // Share functionality
            function shareCurrentTrack() {
                if (
                    currentTrackIndex < 0 ||
                    !filteredTracks[currentTrackIndex]
                ) {
                    showToast("No track selected");
                    return;
                }
                const track = filteredTracks[currentTrackIndex];
                const position = wasmPlayer
                    ? wasmPlayer.position_percentage()
                    : 0;

                // Build clean URL (remove existing params first)
                const url = new URL(
                    window.location.origin + window.location.pathname,
                );
                url.searchParams.set("track", track.path);

                // Include subsong if not the first one
                if (
                    wasmPlayer &&
                    wasmPlayer.subsongCount &&
                    wasmPlayer.subsongCount() > 1
                ) {
                    const currentSub = wasmPlayer.currentSubsong();
                    if (currentSub > 1) {
                        url.searchParams.set("sub", currentSub);
                    }
                }

                if (position > 0.01 && wasmPlayer) {
                    url.searchParams.set(
                        "t",
                        Math.floor(
                            position *
                                (wasmPlayer.metadata?.duration_seconds || 0),
                        ),
                    );
                }

                const shareUrl = url.toString();

                // Try clipboard API, fallback to manual copy
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard
                        .writeText(shareUrl)
                        .then(() => {
                            showToast("Link copied!");
                        })
                        .catch(() => {
                            fallbackCopyToClipboard(shareUrl);
                        });
                } else {
                    fallbackCopyToClipboard(shareUrl);
                }
            }

            function fallbackCopyToClipboard(text) {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand("copy");
                    showToast("Link copied to clipboard!");
                } catch (err) {
                    showToast("Failed to copy link");
                }
                document.body.removeChild(textArea);
            }

            // Sidebar toggle
            let sidebarVisible = true;
            function toggleSidebar() {
                sidebarVisible = !sidebarVisible;
                if (sidebarVisible) {
                    elements.sidebar.classList.remove("w-0", "overflow-hidden");
                    elements.sidebar.classList.add("w-72", "lg:w-80");
                    elements.sidebarToggle.classList.add("hidden");
                    // Show backdrop on mobile
                    if (window.innerWidth < 1024) {
                        elements.sidebarBackdrop.classList.remove("hidden");
                    }
                } else {
                    elements.sidebar.classList.add("w-0", "overflow-hidden");
                    elements.sidebar.classList.remove("w-72", "lg:w-80");
                    elements.sidebarToggle.classList.remove("hidden");
                    elements.sidebarBackdrop.classList.add("hidden");
                }
            }

            function closeSidebarOnMobile() {
                if (window.innerWidth < 1024 && sidebarVisible) {
                    toggleSidebar();
                }
            }

            // Keyboard shortcuts
            function handleKeyboardShortcuts(e) {
                // Don't trigger if typing in an input
                if (
                    e.target.tagName === "INPUT" ||
                    e.target.tagName === "TEXTAREA" ||
                    e.target.tagName === "SELECT"
                )
                    return;

                switch (e.key.toLowerCase()) {
                    case " ": // Space - Play/Pause
                        e.preventDefault();
                        togglePlayPause();
                        break;
                    case "arrowleft": // Previous or seek back
                        if (e.shiftKey && wasmPlayer) {
                            wasmPlayer.seek_to_percentage(
                                Math.max(
                                    0,
                                    wasmPlayer.position_percentage() - 0.05,
                                ),
                            );
                            updateProgressUI();
                        }
                        break;
                    case "arrowright": // Next or seek forward
                        if (e.shiftKey && wasmPlayer) {
                            wasmPlayer.seek_to_percentage(
                                Math.min(
                                    1,
                                    wasmPlayer.position_percentage() + 0.05,
                                ),
                            );
                            updateProgressUI();
                        } else if (!e.shiftKey) {
                            playNext();
                        }
                        break;
                    case "arrowup": // Volume up
                        e.preventDefault();
                        elements.volumeSlider.value = Math.min(
                            100,
                            parseInt(elements.volumeSlider.value) + 10,
                        );
                        elements.volumeSlider.dispatchEvent(new Event("input"));
                        break;
                    case "arrowdown": // Volume down
                        e.preventDefault();
                        elements.volumeSlider.value = Math.max(
                            0,
                            parseInt(elements.volumeSlider.value) - 10,
                        );
                        elements.volumeSlider.dispatchEvent(new Event("input"));
                        break;
                    case "m": // Mute/unmute
                        elements.volumeSlider.value =
                            elements.volumeSlider.value > 0 ? 0 : 100;
                        elements.volumeSlider.dispatchEvent(new Event("input"));
                        break;
                    case "s": // Shuffle toggle
                        toggleShuffle();
                        break;
                    case "n": // Auto-play next toggle
                        toggleAutoPlay();
                        break;
                    case "a": // Set loop A
                        if (!e.ctrlKey && !e.metaKey) setLoopA();
                        break;
                    case "b": // Set loop B
                        setLoopB();
                        break;
                    case "c": // Clear loop (Shift+C)
                        if (e.shiftKey) clearLoop();
                        break;
                    case "r": // Restart
                        restart();
                        break;
                    case "f": // Toggle favorite
                        if (
                            !e.ctrlKey &&
                            !e.metaKey &&
                            currentTrackIndex >= 0 &&
                            filteredTracks[currentTrackIndex]
                        ) {
                            toggleFavorite(
                                filteredTracks[currentTrackIndex].path,
                            );
                        }
                        break;
                    case "tab": // Toggle sidebar
                        e.preventDefault();
                        toggleSidebar();
                        break;
                    case "escape": // Hide sidebar
                        if (sidebarVisible) toggleSidebar();
                        break;
                    case "[": // Previous subsong
                        prevSubsong();
                        break;
                    case "]": // Next subsong
                        nextSubsong();
                        break;
                }
            }

            function prevSubsong() {
                if (
                    !wasmPlayer ||
                    !wasmPlayer.subsongCount ||
                    wasmPlayer.subsongCount() <= 1
                )
                    return;
                const current = wasmPlayer.currentSubsong();
                if (current > 1) {
                    changeSubsong(current - 1);
                    elements.subsongSelect.value = current - 1;
                }
            }

            function nextSubsong() {
                if (
                    !wasmPlayer ||
                    !wasmPlayer.subsongCount ||
                    wasmPlayer.subsongCount() <= 1
                )
                    return;
                const current = wasmPlayer.currentSubsong();
                const count = wasmPlayer.subsongCount();
                if (current < count) {
                    changeSubsong(current + 1);
                    elements.subsongSelect.value = current + 1;
                }
            }

            function updatePlayButton() {
                elements.playIcon.classList.toggle("hidden", isPlaying);
                elements.pauseIcon.classList.toggle("hidden", !isPlaying);
                // Toggle glow animation when playing
                elements.playBtn.classList.toggle("playing", isPlaying);
            }

            function formatTime(seconds) {
                const m = Math.floor(seconds / 60);
                const s = Math.floor(seconds % 60);
                return `${m}:${s.toString().padStart(2, "0")}`;
            }

            // ============================================================================
            // Visualization
            // ============================================================================
            function startVisualization() {
                if (animationId) return;
                animationId = requestAnimationFrame(visualizationLoop);
            }

            function stopVisualization() {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }

            function resetVisualization() {
                // Don't clear waveforms immediately - let them decay naturally
                // Just reset UI elements
                for (const arr of channelSpectrums) arr.fill(0);
                combinedSpectrum.fill(0);
                for (let i = 0; i < channelPhases.length; i++)
                    channelPhases[i] = 0;
                for (const noteEl of channelNotes) {
                    if (noteEl) noteEl.textContent = "---";
                }
                elements.envelopeShape.textContent = "-";
                // Keep LMC1992 panel visible for visual stability
                drawAllVisualization();
            }

            // Clear all waveforms immediately (used when switching songs)
            function clearAllWaveforms() {
                for (const arr of channelWaveforms) arr.fill(0);
                monoWaveform.fill(0);
                for (const arr of channelSpectrums) arr.fill(0);
                combinedSpectrum.fill(0);
                // Also clear the per-channel sample ring buffers
                for (const buf of channelSampleBuffers) buf.fill(0);
                audioSampleBuffer.fill(0);
                // Clear note histories
                for (const history of noteHistories) history.length = 0;
                noteScrollOffset = 0;
            }

            // Decay waveforms toward zero when not playing
            function decayWaveforms() {
                const decayFactor = 0.92; // Smooth decay
                for (const arr of channelWaveforms) {
                    for (let i = 0; i < arr.length; i++) {
                        arr[i] *= decayFactor;
                    }
                }
                for (let i = 0; i < monoWaveform.length; i++) {
                    monoWaveform[i] *= decayFactor;
                }
            }

            function visualizationLoop() {
                if (wasmPlayer && isPlaying) {
                    updateVisualizationData();
                    updateProgressUI();
                    updateWaveformPlayhead();
                    checkLoopBoundary();
                } else {
                    // Decay waveforms toward zero when not playing
                    decayWaveforms();
                }
                drawAllVisualization();
                animationId = requestAnimationFrame(visualizationLoop);
            }

            function updateVisualizationData() {
                if (!wasmPlayer) return;

                const states = wasmPlayer.getChannelStates();
                const channelCount = states.channels?.length || 3;

                // Update note displays and history for each channel
                for (
                    let i = 0;
                    i < channelCount && i < channelNotes.length;
                    i++
                ) {
                    const note = states.channels[i]?.note || "---";
                    if (channelNotes[i]) {
                        channelNotes[i].textContent = note;
                    }
                    // Record note to history for tracker-style display
                    if (i < noteHistories.length) {
                        const history = noteHistories[i];
                        const chState = states.channels[i];
                        const amp = chState?.amplitude || 0;
                        const noise = chState?.noiseEnabled || false;
                        const env = chState?.envelopeEnabled || false;
                        const envShape = env ? (states.envelope?.shape ?? "") : "";
                        const envName = env ? (states.envelope?.shapeName || "") : "";

                        // Only add if note actually changed
                        const entrySpacing = 12; // Pixels between entries
                        const lastEntry = history.length > 0 ? history[history.length - 1] : null;
                        const currentNote = note !== "---" ? note : "";
                        const lastNote = lastEntry?.note || "";
                        const noteChanged = currentNote !== lastNote && currentNote !== "";

                        if (noteChanged) {
                            // Scroll existing entries on this channel
                            for (const entry of history) {
                                entry.y += entrySpacing;
                            }
                            history.push({
                                note: currentNote,
                                amp,
                                noise,
                                env,
                                envShape,
                                envName,
                                y: 0
                            });
                            // Limit history size
                            if (history.length > NOTE_HISTORY_SIZE) {
                                history.shift();
                            }
                        }
                    }
                }

                if (states.envelope) {
                    elements.envelopeShape.textContent =
                        states.envelope.shapeName || "-";
                }

                // Update LMC1992 display (SNDH only)
                updateLmc1992Display();

                synthesizeWaveforms(states);
                updateSpectrum(states);
            }

            function updateLmc1992Display() {
                if (!wasmPlayer) {
                    elements.lmc1992Panel.classList.add("hidden");
                    return;
                }

                // Check if getLmc1992State exists
                if (typeof wasmPlayer.getLmc1992State !== "function") {
                    elements.lmc1992Panel.classList.add("hidden");
                    return;
                }

                const lmc = wasmPlayer.getLmc1992State();

                // Check if we got valid data (SNDH format)
                if (!lmc || lmc.masterVolume === undefined) {
                    elements.lmc1992Panel.classList.add("hidden");
                    return;
                }

                elements.lmc1992Panel.classList.remove("hidden");
                elements.lmcMasterVol.textContent = `${lmc.masterVolume} (${lmc.masterVolumeRaw})`;
                elements.lmcLeftVol.textContent = `${lmc.leftVolume} (${lmc.leftVolumeRaw})`;
                elements.lmcRightVol.textContent = `${lmc.rightVolume} (${lmc.rightVolumeRaw})`;
                const bassDb = lmc.bass >= 0 ? `+${lmc.bass}` : lmc.bass;
                elements.lmcBass.textContent = `${bassDb} (${lmc.bassRaw})`;
                const trebleDb =
                    lmc.treble >= 0 ? `+${lmc.treble}` : lmc.treble;
                elements.lmcTreble.textContent = `${trebleDb} (${lmc.trebleRaw})`;
            }

            // Find trigger point (zero-crossing) for stable waveform display
            function findTriggerPoint(
                buffer,
                writePos,
                bufferSize,
                waveformSize,
            ) {
                // Search backwards from write position for a rising zero-crossing
                // Search within the first quarter of the waveform for the trigger point
                const searchLen = Math.min(waveformSize / 4, 64);
                const startPos =
                    (writePos - waveformSize + bufferSize) % bufferSize;

                for (let i = 1; i < searchLen; i++) {
                    const pos = (startPos + i) % bufferSize;
                    const prevPos = (startPos + i - 1) % bufferSize;
                    const curr = buffer[pos];
                    const prev = buffer[prevPos];
                    // Rising zero-crossing (from negative to positive)
                    if (prev <= 0 && curr > 0) {
                        return i; // Return offset from startPos
                    }
                }
                return 0; // No trigger found, start at beginning
            }

            function synthesizeWaveforms(states) {
                const channelCount = states.channels?.length || 0;

                // Use real per-channel samples from ring buffers
                for (
                    let ch = 0;
                    ch < channelCount && ch < channelWaveforms.length;
                    ch++
                ) {
                    const waveform = channelWaveforms[ch];
                    if (!waveform) continue;

                    // Check if we have real sample data for this channel
                    if (
                        ch < channelSampleBuffers.length &&
                        channelSampleBuffers[ch]
                    ) {
                        const srcBuffer = channelSampleBuffers[ch];
                        // Find trigger point for stable display
                        const triggerOffset = findTriggerPoint(
                            srcBuffer,
                            channelSampleWritePos,
                            AUDIO_VIS_BUFFER_SIZE,
                            WAVEFORM_SIZE,
                        );
                        const startPos =
                            (channelSampleWritePos -
                                WAVEFORM_SIZE +
                                triggerOffset +
                                AUDIO_VIS_BUFFER_SIZE) %
                            AUDIO_VIS_BUFFER_SIZE;

                        // Copy samples with trigger synchronization
                        for (let i = 0; i < WAVEFORM_SIZE; i++) {
                            const readPos =
                                (startPos + i) % AUDIO_VIS_BUFFER_SIZE;
                            waveform[i] = srcBuffer[readPos];
                        }
                    }
                }

                // Use real audio samples for mono waveform with trigger synchronization
                // Read more samples and downsample with averaging for smoother display
                const monoOversample = 4; // Read 4x more samples
                const monoReadSize = WAVEFORM_SIZE * monoOversample;
                const monoTriggerOffset = findTriggerPoint(
                    audioSampleBuffer,
                    audioSampleWritePos,
                    AUDIO_VIS_BUFFER_SIZE,
                    monoReadSize,
                );
                const monoStartPos =
                    (audioSampleWritePos -
                        monoReadSize +
                        monoTriggerOffset +
                        AUDIO_VIS_BUFFER_SIZE) %
                    AUDIO_VIS_BUFFER_SIZE;
                for (let i = 0; i < WAVEFORM_SIZE; i++) {
                    // Average monoOversample samples for each display point
                    let sum = 0;
                    for (let j = 0; j < monoOversample; j++) {
                        const readPos =
                            (monoStartPos + i * monoOversample + j) %
                            AUDIO_VIS_BUFFER_SIZE;
                        sum += audioSampleBuffer[readPos];
                    }
                    monoWaveform[i] = sum / monoOversample;
                }
            }

            function synthesizeEnvelope(shape, phase, amplitude) {
                let sample;
                switch (shape & 0x0f) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 9:
                        sample = 1.0 - phase * 2.0;
                        break;
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 15:
                        sample = phase * 2.0 - 1.0;
                        break;
                    case 8:
                        sample = 1.0 - phase * 2.0;
                        break;
                    case 10:
                        sample =
                            phase < 0.5 ? phase * 4.0 - 1.0 : 3.0 - phase * 4.0;
                        break;
                    case 11:
                        sample = phase < 0.5 ? 1.0 - phase * 4.0 : 1.0;
                        break;
                    case 12:
                        sample = phase * 2.0 - 1.0;
                        break;
                    case 13:
                        sample = phase < 0.5 ? phase * 4.0 - 1.0 : 1.0;
                        break;
                    case 14:
                        sample =
                            phase < 0.5 ? 1.0 - phase * 4.0 : phase * 4.0 - 3.0;
                        break;
                    default:
                        sample = 0;
                }
                return sample * amplitude;
            }

            function updateSpectrum(states) {
                const channelCount = states.channels?.length || 0;

                // Apply decay to all channel spectrums
                for (const spectrum of channelSpectrums) {
                    for (let i = 0; i < SPECTRUM_BINS; i++) {
                        spectrum[i] *= SPECTRUM_DECAY;
                    }
                }
                for (let i = 0; i < SPECTRUM_BINS; i++) {
                    combinedSpectrum[i] *= SPECTRUM_DECAY;
                }

                // Update each channel's spectrum
                for (
                    let ch = 0;
                    ch < channelCount && ch < channelSpectrums.length;
                    ch++
                ) {
                    const chState = states.channels[ch];
                    const spectrum = channelSpectrums[ch];
                    if (!chState || !spectrum) continue;

                    const hasOutput =
                        chState.toneEnabled ||
                        chState.noiseEnabled ||
                        chState.envelopeEnabled;
                    const amplitude = chState.amplitude || 0;

                    // Handle DAC channels (spread across low-mid frequency range)
                    if (chState.isDac && amplitude > 0) {
                        // DAC audio typically spans lower-mid frequencies
                        // Spread amplitude across bins 4-12 (roughly 100Hz-800Hz range)
                        for (let bin = 4; bin <= 12; bin++) {
                            const falloff = 1.0 - Math.abs(bin - 8) / 8;
                            spectrum[bin] = Math.max(
                                spectrum[bin],
                                amplitude * falloff * 0.8,
                            );
                        }
                    } else if (!hasOutput && amplitude > 0) {
                        // SID/Digidrum mode: spread across mid frequencies like DAC
                        for (let bin = 4; bin <= 14; bin++) {
                            const falloff = 1.0 - Math.abs(bin - 9) / 10;
                            spectrum[bin] = Math.max(
                                spectrum[bin],
                                amplitude * falloff * 0.9,
                            );
                        }
                    } else if (
                        hasOutput &&
                        amplitude > 0 &&
                        chState.frequency > 0
                    ) {
                        const bin = freqToBin(chState.frequency);
                        spectrum[bin] = Math.max(spectrum[bin], amplitude);
                    }
                }

                // Calculate combined spectrum as max of all channels
                for (let i = 0; i < SPECTRUM_BINS; i++) {
                    let max = 0;
                    for (let ch = 0; ch < channelSpectrums.length; ch++) {
                        max = Math.max(max, channelSpectrums[ch][i]);
                    }
                    combinedSpectrum[i] = max;
                }
            }

            function freqToBin(freq) {
                if (freq <= 0) return 0;
                const octavesAboveC1 = Math.log2(freq / SPECTRUM_BASE_FREQ);
                const bin = Math.round(octavesAboveC1 * BINS_PER_OCTAVE);
                return Math.max(0, Math.min(SPECTRUM_BINS - 1, bin));
            }

            function drawAllVisualization() {
                // Note scrolling is now handled per-channel when new notes are added
                // Just clean up old entries that have scrolled off screen
                for (const history of noteHistories) {
                    while (history.length > 0 && history[0].y > 150) {
                        history.shift();
                    }
                }

                // Draw each channel's oscilloscope with note history
                for (let ch = 0; ch < channelWaveforms.length; ch++) {
                    const ctx = channelContexts.osc[ch];
                    const color = getChannelColor(ch);
                    const history = ch < noteHistories.length ? noteHistories[ch] : null;
                    drawOscilloscope(ctx, channelWaveforms[ch], color, history);
                }
                // Draw mono combined oscilloscope (no note history)
                drawOscilloscope(contexts.oscMono, monoWaveform, COLORS.green, null);

                // Draw each channel's spectrum
                for (let ch = 0; ch < channelSpectrums.length; ch++) {
                    const ctx = channelContexts.spec[ch];
                    const color = getChannelColor(ch);
                    drawSpectrum(ctx, channelSpectrums[ch], color);
                }
                // Draw combined spectrum
                drawSpectrum(
                    contexts.specCombined,
                    combinedSpectrum,
                    COLORS.green,
                );
            }

            function drawOscilloscope(ctx, data, color, noteHistory = null) {
                if (!ctx) return;
                const canvas = ctx.canvas;
                const dpr = window.devicePixelRatio || 1;
                const w = canvas.width / dpr;
                const h = canvas.height / dpr;
                if (w === 0 || h === 0) return;

                // Phosphor persistence effect - fade previous frame instead of clearing
                ctx.fillStyle = "rgba(10, 10, 15, 0.20)";
                ctx.fillRect(0, 0, w, h);

                // Draw tracker-style scrolling data in background
                if (noteHistory && noteHistory.length > 0) {
                    ctx.font = "8px monospace";
                    ctx.textAlign = "left";
                    const blockX = w / 2 - 25; // Fixed left edge for block alignment
                    for (const entry of noteHistory) {
                        // Calculate alpha based on position (fade as it scrolls up)
                        const alpha = Math.max(0, 1 - entry.y / h) * 0.5;
                        const y = h - entry.y;
                        if (y > 0 && y < h) {
                            // Build display string: ### NOTE NE////
                            const volBar = "â–®".repeat(Math.ceil(entry.amp * 3)).padEnd(3, " ");
                            const noteText = (entry.note || "Â·Â·Â·").padStart(3, " ").padEnd(4, " ");
                            let flags = "";
                            if (entry.noise) flags += "N";
                            if (entry.env) flags += "E";
                            const envText = entry.envName || "";

                            // Draw as fixed-width block with spacing
                            const line = volBar + "  " + noteText + "  " + flags + envText;
                            ctx.fillStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                            ctx.fillText(line, blockX, y);
                        }
                    }
                }

                // Draw grid
                ctx.strokeStyle = "rgba(139, 92, 246, 0.08)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Vertical lines (8 divisions)
                for (let i = 1; i < 8; i++) {
                    const x = (w / 8) * i;
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                }
                // Horizontal lines (4 divisions)
                for (let i = 1; i < 4; i++) {
                    const y = (h / 4) * i;
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                }
                ctx.stroke();

                // Center line (brighter)
                ctx.strokeStyle = "rgba(139, 92, 246, 0.2)";
                ctx.beginPath();
                ctx.moveTo(0, h / 2);
                ctx.lineTo(w, h / 2);
                ctx.stroke();

                // Build the waveform path
                ctx.beginPath();
                const step = w / data.length;
                const amp = 2.5; // Amplification factor for better visibility
                for (let i = 0; i < data.length; i++) {
                    const x = i * step;
                    const y = Math.max(
                        0,
                        Math.min(h, h / 2 - data[i] * (h / 2) * amp),
                    );
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }

                // Draw glow layers (outer to inner) for phosphor effect
                ctx.strokeStyle = color + "08";
                ctx.lineWidth = 12;
                ctx.stroke();

                ctx.strokeStyle = color + "15";
                ctx.lineWidth = 8;
                ctx.stroke();

                ctx.strokeStyle = color + "30";
                ctx.lineWidth = 5;
                ctx.stroke();

                ctx.strokeStyle = color + "60";
                ctx.lineWidth = 3;
                ctx.stroke();

                // Core bright line
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Hot center (white-ish)
                ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }

            function drawSpectrum(ctx, data, color) {
                if (!ctx) return;
                const canvas = ctx.canvas;
                const dpr = window.devicePixelRatio || 1;
                const w = canvas.width / dpr;
                const h = canvas.height / dpr;
                if (w === 0 || h === 0) return;

                ctx.fillStyle = "#0a0a0f";
                ctx.fillRect(0, 0, w, h);

                const barWidth = w / SPECTRUM_BINS - 1;
                for (let i = 0; i < SPECTRUM_BINS; i++) {
                    const x = i * (barWidth + 1);
                    const barHeight = data[i] * h * 0.9;
                    const y = h - barHeight;
                    const gradient = ctx.createLinearGradient(x, h, x, y);
                    gradient.addColorStop(0, color + "30");
                    gradient.addColorStop(1, color);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, barWidth, barHeight);
                }
            }

            function updateProgressUI() {
                if (!wasmPlayer) return;
                const position = wasmPlayer.position_percentage();
                const duration = wasmPlayer.metadata.duration_seconds;
                elements.progressBar.value = position * 100;
                elements.currentTime.textContent = formatTime(
                    position * duration,
                );

                // Auto-play: advance to next track when song loops
                if (autoPlayEnabled && wasmPlayer.loop_count() > 0) {
                    playNext();
                }
            }

            // ============================================================================
            // Waveform Overview (Scrubbing) - Pre-rendered from catalog
            // ============================================================================

            // IndexedDB for waveform cache
            const WAVEFORM_DB_NAME = "ym2149-waveforms";
            const WAVEFORM_STORE_NAME = "waveforms";
            let waveformDb = null;

            async function openWaveformDb() {
                if (waveformDb) return waveformDb;
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(WAVEFORM_DB_NAME, 1);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        waveformDb = request.result;
                        resolve(waveformDb);
                    };
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(WAVEFORM_STORE_NAME)) {
                            db.createObjectStore(WAVEFORM_STORE_NAME);
                        }
                    };
                });
            }

            async function getCachedWaveform(fingerprint) {
                try {
                    const db = await openWaveformDb();
                    return new Promise((resolve) => {
                        const tx = db.transaction(WAVEFORM_STORE_NAME, "readonly");
                        const store = tx.objectStore(WAVEFORM_STORE_NAME);
                        const request = store.get(fingerprint);
                        request.onsuccess = () => resolve(request.result || null);
                        request.onerror = () => resolve(null);
                    });
                } catch {
                    return null;
                }
            }

            async function cacheWaveform(fingerprint, peaks) {
                try {
                    const db = await openWaveformDb();
                    const tx = db.transaction(WAVEFORM_STORE_NAME, "readwrite");
                    const store = tx.objectStore(WAVEFORM_STORE_NAME);
                    store.put(Array.from(peaks), fingerprint);
                } catch (err) {
                    console.warn("Failed to cache waveform:", err);
                }
            }

            // Simple hash for file fingerprint
            async function computeFileFingerprint(data) {
                const hashBuffer = await crypto.subtle.digest("SHA-256", data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
            }

            // Generate waveform overview from file data
            async function generateWaveformOverview(data, durationSeconds) {
                const WAVEFORM_BARS = 200; // Number of bars in overview
                const sampleRate = 44100;
                const totalSamples = Math.ceil(durationSeconds * sampleRate);
                const samplesPerBar = Math.ceil(totalSamples / WAVEFORM_BARS);

                // Create a temporary player
                const tempPlayer = new Ym2149Player(data);
                tempPlayer.play();

                const peaks = new Float32Array(WAVEFORM_BARS);
                const chunkSize = 4096;

                let sampleIndex = 0;
                let barIndex = 0;
                let barMax = 0;
                let barSampleCount = 0;

                while (barIndex < WAVEFORM_BARS && sampleIndex < totalSamples) {
                    const samplesToGenerate = Math.min(chunkSize, totalSamples - sampleIndex);
                    const samples = tempPlayer.generateSamples(samplesToGenerate);

                    for (let i = 0; i < samples.length && barIndex < WAVEFORM_BARS; i++) {
                        const abs = Math.abs(samples[i]);
                        if (abs > barMax) barMax = abs;
                        barSampleCount++;

                        if (barSampleCount >= samplesPerBar) {
                            peaks[barIndex] = barMax;
                            barIndex++;
                            barMax = 0;
                            barSampleCount = 0;
                        }
                    }

                    sampleIndex += samplesToGenerate;

                    // Yield to UI every few chunks
                    if (sampleIndex % (chunkSize * 10) === 0) {
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                // Handle last partial bar
                if (barSampleCount > 0 && barIndex < WAVEFORM_BARS) {
                    peaks[barIndex] = barMax;
                }

                return peaks;
            }

            // Load or generate waveform for user-loaded file
            async function loadOrGenerateWaveform(data, durationSeconds) {
                const fingerprint = await computeFileFingerprint(data);

                // Try cache first
                const cached = await getCachedWaveform(fingerprint);
                if (cached) {
                    console.log("Waveform loaded from cache");
                    waveformOverviewData = new Float32Array(cached);
                    showWaveformScrubber();
                    return;
                }

                // Generate in background
                console.log("Generating waveform overview...");
                try {
                    const peaks = await generateWaveformOverview(data, durationSeconds);
                    waveformOverviewData = peaks;
                    showWaveformScrubber();

                    // Cache for next time
                    await cacheWaveform(fingerprint, peaks);
                    console.log("Waveform cached");
                } catch (err) {
                    console.error("Waveform generation failed:", err);
                }
            }

            function showWaveformScrubber() {
                elements.waveformScrubber.classList.remove("hidden");
                elements.progressContainer.classList.add("hidden");
                requestAnimationFrame(() => {
                    drawWaveformOverview();
                    const duration = wasmPlayer?.metadata?.duration_seconds || 0;
                    elements.waveformTotalTime.textContent = formatTime(duration);
                    elements.waveformCurrentTime.textContent = "0:00";
                });
            }

            function loadPrerenderedWaveform(base64Data) {
                try {
                    // Decode base64 waveform data
                    const binaryStr = atob(base64Data);
                    const peaks = new Float32Array(binaryStr.length);
                    for (let i = 0; i < binaryStr.length; i++) {
                        peaks[i] = binaryStr.charCodeAt(i) / 255; // Normalize 0-255 to 0-1
                    }

                    waveformOverviewData = peaks;

                    // Show waveform, hide fallback progress bar
                    elements.waveformScrubber.classList.remove("hidden");
                    elements.progressContainer.classList.add("hidden");

                    // Draw immediately
                    requestAnimationFrame(() => {
                        drawWaveformOverview();
                        const duration =
                            wasmPlayer?.metadata?.duration_seconds || 0;
                        elements.waveformTotalTime.textContent =
                            formatTime(duration);
                        elements.waveformCurrentTime.textContent = "0:00";
                    });
                } catch (err) {
                    console.error("Waveform decode error:", err);
                    elements.waveformScrubber.classList.add("hidden");
                    elements.progressContainer.classList.remove("hidden");
                }
            }

            function drawWaveformOverview() {
                if (!waveformOverviewData) return;

                const canvas = elements.waveformOverview;
                const ctx = canvas.getContext("2d");

                // Set canvas resolution
                const rect = canvas.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) return;

                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

                const width = rect.width;
                const height = rect.height;
                const barCount = waveformOverviewData.length;
                const barWidth = width / barCount;
                const centerY = height / 2;
                const maxBarHeight = (height - 16) / 2; // Leave room for time text

                // Clear with dark background
                ctx.fillStyle = "#0d0d14";
                ctx.fillRect(0, 0, width, height);

                // Find max peak for normalization
                let maxPeak = 0;
                for (let i = 0; i < barCount; i++) {
                    if (waveformOverviewData[i] > maxPeak)
                        maxPeak = waveformOverviewData[i];
                }
                const normalizer = maxPeak > 0 ? 1 / maxPeak : 1;

                // Create gradient for bars
                const gradient = ctx.createLinearGradient(
                    0,
                    centerY - maxBarHeight,
                    0,
                    centerY + maxBarHeight,
                );
                gradient.addColorStop(0, "#8b5cf6");
                gradient.addColorStop(0.35, "#06b6d4");
                gradient.addColorStop(0.5, "#22d3ee");
                gradient.addColorStop(0.65, "#06b6d4");
                gradient.addColorStop(1, "#8b5cf6");

                ctx.fillStyle = gradient;

                // Draw individual bars with small gaps (SoundCloud style)
                const gap = Math.max(0.5, barWidth * 0.15);
                const actualBarWidth = barWidth - gap;

                for (let i = 0; i < barCount; i++) {
                    const peak = waveformOverviewData[i] * normalizer;
                    const barHeight = Math.max(2, peak * maxBarHeight);
                    const x = i * barWidth + gap / 2;

                    // Draw mirrored bar (top and bottom)
                    ctx.beginPath();
                    ctx.roundRect(
                        x,
                        centerY - barHeight,
                        actualBarWidth,
                        barHeight * 2,
                        1,
                    );
                    ctx.fill();
                }

                // Add subtle glow overlay
                ctx.globalCompositeOperation = "lighter";
                ctx.fillStyle = "rgba(6, 182, 212, 0.05)";
                ctx.fillRect(0, 0, width, height);
                ctx.globalCompositeOperation = "source-over";

                // Draw center line
                ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();
            }

            function updateWaveformPlayhead() {
                if (!wasmPlayer) return;
                const position = wasmPlayer.position_percentage();
                elements.waveformPlayhead.style.left = `${position * 100}%`;
                const duration = wasmPlayer.metadata?.duration_seconds || 0;
                elements.waveformCurrentTime.textContent = formatTime(
                    position * duration,
                );
            }

            function updateWaveformLoopMarkers() {
                if (loopA !== null) {
                    elements.waveformLoopA.style.left = `${loopA * 100}%`;
                    elements.waveformLoopA.classList.remove("hidden");
                } else {
                    elements.waveformLoopA.classList.add("hidden");
                }

                if (loopB !== null) {
                    elements.waveformLoopB.style.left = `${loopB * 100}%`;
                    elements.waveformLoopB.classList.remove("hidden");
                } else {
                    elements.waveformLoopB.classList.add("hidden");
                }

                if (loopA !== null && loopB !== null) {
                    const left = Math.min(loopA, loopB) * 100;
                    const right = Math.max(loopA, loopB) * 100;
                    elements.waveformLoopRegion.style.left = `${left}%`;
                    elements.waveformLoopRegion.style.width = `${right - left}%`;
                    elements.waveformLoopRegion.classList.remove("hidden");
                } else {
                    elements.waveformLoopRegion.classList.add("hidden");
                }
            }

            let isScrubbing = false;

            function getEventX(e) {
                // Handle both mouse and touch events
                if (e.touches && e.touches.length > 0) {
                    return e.touches[0].clientX;
                }
                if (e.changedTouches && e.changedTouches.length > 0) {
                    return e.changedTouches[0].clientX;
                }
                return e.clientX;
            }

            function handleWaveformScrub(e) {
                if (!wasmPlayer) return;

                const rect = elements.waveformScrubber.getBoundingClientRect();
                const x = getEventX(e) - rect.left;
                const position = Math.max(0, Math.min(1, x / rect.width));

                wasmPlayer.seek_to_percentage(position);
                updateProgressUI();
                updateWaveformPlayhead();
            }

            function startScrubbing(e) {
                if (!wasmPlayer) return;
                e.preventDefault();
                isScrubbing = true;
                handleWaveformScrub(e);
            }

            function continueScrubbing(e) {
                if (!isScrubbing) return;
                e.preventDefault();
                handleWaveformScrub(e);
            }

            function stopScrubbing(e) {
                if (!isScrubbing) return;
                isScrubbing = false;
            }

            // ============================================================================
            // WAV Export
            // ============================================================================
            function showExportModal() {
                if (!wasmPlayer) return;
                // Set default duration to song length
                const duration = Math.ceil(
                    wasmPlayer.metadata.duration_seconds,
                );
                elements.exportDuration.value = duration > 0 ? duration : 180;
                elements.exportMode.value = "mixed";
                elements.exportStemOptions.classList.add("hidden");

                // Populate channel checkboxes
                const channelCount = wasmPlayer.channelCount
                    ? wasmPlayer.channelCount()
                    : 3;
                let checkboxHtml = "";
                const channelNames = getChannelNames(channelCount);
                for (let i = 0; i < channelCount; i++) {
                    checkboxHtml += `
                        <label class="flex items-center gap-1 bg-gray-800 rounded px-2 py-1 cursor-pointer">
                            <input type="checkbox" class="export-channel-cb" value="${i}" checked />
                            <span class="text-xs">${channelNames[i]}</span>
                        </label>`;
                }
                elements.exportChannelCheckboxes.innerHTML = checkboxHtml;

                elements.exportModal.classList.remove("hidden");
                elements.exportProgress.classList.add("hidden");
            }

            function hideExportModal() {
                elements.exportModal.classList.add("hidden");
            }

            function getChannelNames(channelCount) {
                const format = currentFormat.toUpperCase();
                if (format === "SNDH" && channelCount === 5) {
                    return ["CH A", "CH B", "CH C", "DAC L", "DAC R"];
                } else if (channelCount === 6) {
                    return ["CH A", "CH B", "CH C", "CH D", "CH E", "CH F"];
                } else {
                    return Array.from(
                        { length: channelCount },
                        (_, i) => `CH ${String.fromCharCode(65 + i)}`,
                    );
                }
            }

            async function exportWav() {
                if (!wasmPlayer) return;
                // Need either a catalog track or user-loaded file data
                if (currentTrackIndex < 0 && !loadedFileData) return;

                const duration = parseInt(elements.exportDuration.value) || 180;
                const exportMode = elements.exportMode.value;
                // Sample rate is fixed at 44100 in the WASM player
                const sampleRate = 44100;
                const numSamples = duration * sampleRate;

                elements.exportProgress.classList.remove("hidden");
                elements.exportStart.disabled = true;

                try {
                    // Get data from catalog track or user-loaded file
                    let data;
                    let trackTitle;
                    if (currentTrackIndex >= 0 && filteredTracks[currentTrackIndex]) {
                        const track = filteredTracks[currentTrackIndex];
                        data = await loadTrack(track.path);
                        trackTitle = track.title || "track";
                    } else if (loadedFileData) {
                        data = loadedFileData;
                        trackTitle = loadedFileName ? loadedFileName.replace(/\.[^/.]+$/, "") : "track";
                    } else {
                        throw new Error("No track loaded");
                    }

                    if (exportMode === "stems") {
                        // Get selected channels
                        const selectedChannels = [];
                        elements.exportChannelCheckboxes
                            .querySelectorAll(".export-channel-cb:checked")
                            .forEach((cb) => {
                                selectedChannels.push(parseInt(cb.value));
                            });

                        if (selectedChannels.length === 0) {
                            alert(
                                "Please select at least one channel to export",
                            );
                            return;
                        }

                        const channelNames = getChannelNames(
                            wasmPlayer.channelCount
                                ? wasmPlayer.channelCount()
                                : 3,
                        );

                        // Export each selected channel as a separate file
                        for (let i = 0; i < selectedChannels.length; i++) {
                            const ch = selectedChannels[i];
                            const channelCount = wasmPlayer.channelCount
                                ? wasmPlayer.channelCount()
                                : 3;

                            // Create a fresh player for each channel
                            const exportPlayer = new Ym2149Player(data);
                            exportPlayer.play();

                            // Mute all channels except the current one
                            for (let c = 0; c < channelCount; c++) {
                                exportPlayer.setChannelMute(c, c !== ch);
                            }

                            const chunkSize = sampleRate;
                            const samples = new Float32Array(numSamples);
                            let offset = 0;

                            while (offset < numSamples) {
                                const remaining = Math.min(
                                    chunkSize,
                                    numSamples - offset,
                                );
                                const chunk =
                                    exportPlayer.generateSamples(remaining);
                                samples.set(chunk, offset);
                                offset += remaining;

                                // Update progress for all channels combined
                                const totalProgress =
                                    (i + offset / numSamples) /
                                    selectedChannels.length;
                                elements.exportProgressBar.style.width = `${totalProgress * 100}%`;
                                await new Promise((r) => setTimeout(r, 0));
                            }

                            const wavBuffer = createWavFile(
                                samples,
                                sampleRate,
                            );
                            const blob = new Blob([wavBuffer], {
                                type: "audio/wav",
                            });
                            const url = URL.createObjectURL(blob);

                            const a = document.createElement("a");
                            a.href = url;
                            const chName = channelNames[ch].replace(
                                /\s+/g,
                                "_",
                            );
                            a.download = `${trackTitle}_${chName}.wav`;
                            a.click();
                            URL.revokeObjectURL(url);

                            // Small delay between downloads
                            await new Promise((r) => setTimeout(r, 200));
                        }
                    } else {
                        // Mixed mode - export all channels mixed together
                        const exportPlayer = new Ym2149Player(data);
                        exportPlayer.play();

                        const chunkSize = sampleRate;
                        const samples = new Float32Array(numSamples);
                        let offset = 0;

                        while (offset < numSamples) {
                            const remaining = Math.min(
                                chunkSize,
                                numSamples - offset,
                            );
                            const chunk =
                                exportPlayer.generateSamples(remaining);
                            samples.set(chunk, offset);
                            offset += remaining;
                            elements.exportProgressBar.style.width = `${(offset / numSamples) * 100}%`;
                            await new Promise((r) => setTimeout(r, 0));
                        }

                        const wavBuffer = createWavFile(samples, sampleRate);
                        const blob = new Blob([wavBuffer], {
                            type: "audio/wav",
                        });
                        const url = URL.createObjectURL(blob);

                        const a = document.createElement("a");
                        a.href = url;
                        a.download = `${trackTitle}.wav`;
                        a.click();
                        URL.revokeObjectURL(url);
                    }
                } catch (err) {
                    console.error("Export error:", err);
                    alert("Export failed: " + err.message);
                } finally {
                    hideExportModal();
                    elements.exportStart.disabled = false;
                }
            }

            function createWavFile(samples, sampleRate) {
                const numChannels = 1;
                const bitsPerSample = 16;
                const bytesPerSample = bitsPerSample / 8;
                const blockAlign = numChannels * bytesPerSample;
                const byteRate = sampleRate * blockAlign;
                const dataSize = samples.length * bytesPerSample;
                const buffer = new ArrayBuffer(44 + dataSize);
                const view = new DataView(buffer);

                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                writeString(0, "RIFF");
                view.setUint32(4, 36 + dataSize, true);
                writeString(8, "WAVE");
                writeString(12, "fmt ");
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, bitsPerSample, true);
                writeString(36, "data");
                view.setUint32(40, dataSize, true);

                let offset = 44;
                for (let i = 0; i < samples.length; i++) {
                    const sample = Math.max(-1, Math.min(1, samples[i]));
                    view.setInt16(offset, sample * 32767, true);
                    offset += 2;
                }

                return buffer;
            }

            // ============================================================================
            // Drag & Drop
            // ============================================================================
            function setupDragDrop() {
                document.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    elements.dropZone.classList.remove("hidden");
                });

                document.addEventListener("dragleave", (e) => {
                    if (e.relatedTarget === null) {
                        elements.dropZone.classList.add("hidden");
                    }
                });

                document.addEventListener("drop", async (e) => {
                    e.preventDefault();
                    elements.dropZone.classList.add("hidden");

                    const file = e.dataTransfer.files[0];
                    if (!file) return;

                    await loadFromFile(file);
                });
            }

            async function loadFromFile(file) {
                try {
                    await ensureAudioContext();
                    const buffer = await file.arrayBuffer();
                    const data = new Uint8Array(buffer);

                    wasmPlayer = new Ym2149Player(data);
                    wasmPlayer.set_volume(elements.volumeSlider.value / 100);
                    currentTrackIndex = -1;
                    loadedFileData = data; // Store for export
                    loadedFileName = file.name;

                    // Reset waveform, show fallback progress bar initially
                    waveformOverviewData = null;
                    elements.waveformScrubber.classList.add("hidden");
                    elements.progressContainer.classList.remove("hidden");

                    const meta = wasmPlayer.metadata;
                    currentFormat = meta.format || "";

                    // Setup channel UI for multi-chip support
                    const channelCount = wasmPlayer.channelCount
                        ? wasmPlayer.channelCount()
                        : 3;
                    console.log(
                        "Dropped file channel count:",
                        channelCount,
                        "format:",
                        currentFormat,
                    );
                    setupChannelUI(channelCount);

                    // Clear all oscilloscope waveforms after channel setup
                    clearAllWaveforms();
                    drawAllVisualization(); // Force immediate redraw with zeroed waveforms

                    elements.songTitle.textContent = file.name;
                    elements.songAuthor.textContent =
                        meta.author || "Dropped file";
                    elements.songFormat.textContent = meta.format || "-";
                    elements.songFrames.textContent = `${meta.frame_count} frames`;
                    elements.totalTime.textContent = formatTime(
                        meta.duration_seconds,
                    );

                    enableControls();
                    resetVisualization();
                    updateLmc1992Display(); // Show LMC1992 panel for SNDH

                    wasmPlayer.play();
                    isPlaying = true;
                    startAudioProcessing();
                    startVisualization();
                    updatePlayButton();

                    // Generate waveform overview in background (with caching)
                    loadOrGenerateWaveform(data, meta.duration_seconds);
                } catch (err) {
                    console.error("Load error:", err);
                }
            }

            // ============================================================================
            // Event Handlers
            // ============================================================================
            function setupEventHandlers() {
                // iOS audio unlock on first touch
                const unlockAudio = async () => {
                    await ensureAudioContext();
                    document.removeEventListener("touchstart", unlockAudio);
                    document.removeEventListener("touchend", unlockAudio);
                    document.removeEventListener("click", unlockAudio);
                };
                document.addEventListener("touchstart", unlockAudio, {
                    once: true,
                });
                document.addEventListener("touchend", unlockAudio, {
                    once: true,
                });
                document.addEventListener("click", unlockAudio, { once: true });

                // Search
                let searchTimeout;
                elements.searchInput.addEventListener("input", () => {
                    clearTimeout(searchTimeout);
                    // Show/hide clear button
                    elements.searchClear.classList.toggle(
                        "hidden",
                        !elements.searchInput.value,
                    );
                    searchTimeout = setTimeout(() => {
                        searchQuery = elements.searchInput.value.trim();
                        filterAndGroupTracks();
                    }, 150);
                });

                // Search clear button
                elements.searchClear.addEventListener("click", () => {
                    elements.searchInput.value = "";
                    elements.searchClear.classList.add("hidden");
                    searchQuery = "";
                    filterAndGroupTracks();
                    elements.searchInput.focus();
                });

                // Virtual scroll
                elements.trackList.addEventListener("scroll", () => {
                    requestAnimationFrame(updateVisibleRows);
                });

                // Toggle collapse all button
                const toggleCollapseBtn =
                    document.getElementById("toggleCollapseBtn");
                toggleCollapseBtn.addEventListener("click", () => {
                    if (allCollapsed) {
                        expandAllAuthors();
                        toggleCollapseBtn.textContent = "Collapse All";
                    } else {
                        collapseAllAuthors();
                        toggleCollapseBtn.textContent = "Expand All";
                    }
                });

                // File input
                elements.fileInput.addEventListener("change", async (e) => {
                    const file = e.target.files[0];
                    if (file) await loadFromFile(file);
                });

                // Player controls
                elements.playBtn.addEventListener("click", togglePlayPause);
                elements.stopBtn.addEventListener("click", stop);
                elements.restartBtn.addEventListener("click", restart);
                elements.nextBtn.addEventListener("click", playNext);
                elements.shuffleBtn.addEventListener("click", toggleShuffle);
                elements.autoPlayBtn.addEventListener("click", toggleAutoPlay);
                elements.loopABtn.addEventListener("click", setLoopA);
                elements.loopBBtn.addEventListener("click", setLoopB);
                elements.loopClearBtn.addEventListener("click", clearLoop);
                elements.speedSelect.addEventListener("change", (e) =>
                    setPlaybackSpeed(parseFloat(e.target.value)),
                );
                elements.subsongSelect.addEventListener("change", (e) =>
                    changeSubsong(parseInt(e.target.value)),
                );
                elements.shareBtn.addEventListener("click", shareCurrentTrack);
                elements.sidebarToggle.addEventListener("click", toggleSidebar);
                elements.mobileMenuBtn.addEventListener("click", toggleSidebar);
                elements.hideSidebarBtn.addEventListener(
                    "click",
                    toggleSidebar,
                );
                elements.sidebarBackdrop.addEventListener(
                    "click",
                    toggleSidebar,
                );

                // Keyboard shortcuts
                document.addEventListener("keydown", handleKeyboardShortcuts);

                // Player favorite button
                elements.playerFavBtn.addEventListener("click", () => {
                    if (
                        currentTrackIndex >= 0 &&
                        filteredTracks[currentTrackIndex]
                    ) {
                        toggleFavorite(filteredTracks[currentTrackIndex].path);
                    }
                });

                // Progress seek
                elements.progressBar.addEventListener("input", () => {
                    if (!wasmPlayer) return;
                    wasmPlayer.seek_to_percentage(
                        elements.progressBar.value / 100,
                    );
                    updateProgressUI();
                });

                // Volume
                elements.volumeSlider.addEventListener("input", () => {
                    if (wasmPlayer)
                        wasmPlayer.set_volume(
                            elements.volumeSlider.value / 100,
                        );
                });

                // Channel mute handlers are added dynamically in setupChannelUI()

                // Visualization mode
                elements.vizModeOsc.addEventListener("click", () => {
                    elements.oscView.classList.remove("hidden");
                    elements.specView.classList.add("hidden");
                    elements.vizModeOsc.classList.remove(
                        "bg-gray-800",
                        "text-gray-400",
                    );
                    elements.vizModeOsc.classList.add(
                        "bg-chip-purple/20",
                        "text-chip-purple",
                        "active",
                    );
                    elements.vizModeSpec.classList.remove(
                        "bg-chip-purple/20",
                        "text-chip-purple",
                        "active",
                    );
                    elements.vizModeSpec.classList.add(
                        "bg-gray-800",
                        "text-gray-400",
                    );
                    requestAnimationFrame(setupAllCanvases);
                });

                elements.vizModeSpec.addEventListener("click", () => {
                    elements.specView.classList.remove("hidden");
                    elements.oscView.classList.add("hidden");
                    elements.vizModeSpec.classList.remove(
                        "bg-gray-800",
                        "text-gray-400",
                    );
                    elements.vizModeSpec.classList.add(
                        "bg-chip-purple/20",
                        "text-chip-purple",
                        "active",
                    );
                    elements.vizModeOsc.classList.remove(
                        "bg-chip-purple/20",
                        "text-chip-purple",
                        "active",
                    );
                    elements.vizModeOsc.classList.add(
                        "bg-gray-800",
                        "text-gray-400",
                    );
                    requestAnimationFrame(setupAllCanvases);
                });

                // Export
                elements.exportBtn.addEventListener("click", showExportModal);
                elements.exportCancel.addEventListener(
                    "click",
                    hideExportModal,
                );
                elements.exportStart.addEventListener("click", exportWav);
                elements.exportMode.addEventListener("change", (e) => {
                    elements.exportStemOptions.classList.toggle(
                        "hidden",
                        e.target.value !== "stems",
                    );
                });

                // Waveform scrubber drag/touch support
                elements.waveformScrubber.addEventListener(
                    "mousedown",
                    startScrubbing,
                );
                document.addEventListener("mousemove", continueScrubbing);
                document.addEventListener("mouseup", stopScrubbing);
                elements.waveformScrubber.addEventListener(
                    "touchstart",
                    startScrubbing,
                    { passive: false },
                );
                document.addEventListener("touchmove", continueScrubbing, {
                    passive: false,
                });
                document.addEventListener("touchend", stopScrubbing);

                // Resize
                window.addEventListener("resize", () => {
                    setupAllCanvases();
                    renderTrackList();
                    if (waveformOverviewData) drawWaveformOverview();
                });

                // Keyboard
                document.addEventListener("keydown", (e) => {
                    if (e.target.tagName === "INPUT") return;

                    switch (e.code) {
                        case "Space":
                            e.preventDefault();
                            togglePlayPause();
                            break;
                        case "ArrowLeft":
                            if (wasmPlayer) {
                                const pos = Math.max(
                                    0,
                                    wasmPlayer.position_percentage() - 0.05,
                                );
                                wasmPlayer.seek_to_percentage(pos);
                            }
                            break;
                        case "ArrowRight":
                            if (wasmPlayer) {
                                const pos = Math.min(
                                    1,
                                    wasmPlayer.position_percentage() + 0.05,
                                );
                                wasmPlayer.seek_to_percentage(pos);
                            }
                            break;
                        case "KeyN":
                            playNext();
                            break;
                    }
                });
            }

            // ============================================================================
            // Initialize
            // ============================================================================
            import("./pkg/ym2149_wasm.js").then((module) => {
                module.default().then(() => {
                    Ym2149Player = module.Ym2149Player;

                    // Initialize default 3-channel UI
                    setupChannelUI(3);
                    setupAllCanvases();
                    setupEventHandlers();
                    setupDragDrop();

                    // Hide sidebar by default on mobile
                    if (window.innerWidth < 768) {
                        sidebarVisible = true; // Will be toggled to false
                        toggleSidebar();
                    }

                    // Load favorites, stats, fingerprints and pinned authors from localStorage
                    loadFavorites();
                    loadPlayStats();
                    loadFingerprints();
                    loadPinnedAuthors();

                    // Load catalog (with caching and gzip support)
                    loadCatalogCached()
                        .then((data) => {
                            catalog = data;

                            // Sort catalog: collection, author, title
                            catalog.tracks.sort((a, b) => {
                                const colOrder = ["sndh", "ym", "ay", "arkos"];
                                const colCmp =
                                    colOrder.indexOf(a.collection) -
                                    colOrder.indexOf(b.collection);
                                if (colCmp !== 0) return colCmp;
                                const authorCmp = (
                                    a.author || ""
                                ).localeCompare(b.author || "");
                                if (authorCmp !== 0) return authorCmp;
                                return (a.title || "").localeCompare(
                                    b.title || "",
                                );
                            });

                            renderCollections();
                            filterAndGroupTracks();

                            // Check URL params (supports 'file', 'track', 'sub' for subsong, and 't' for time)
                            const params = new URLSearchParams(
                                window.location.search,
                            );
                            const file =
                                params.get("file") || params.get("track");
                            const subsong = parseInt(params.get("sub")) || 0;
                            const startTime = parseInt(params.get("t")) || 0;

                            if (file) {
                                // Decode in case of double-encoding
                                const decodedFile = decodeURIComponent(file);

                                // Try multiple matching strategies
                                const track = catalog.tracks.find(
                                    (t) =>
                                        t.path === file ||
                                        t.path === decodedFile ||
                                        t.path.endsWith(file) ||
                                        t.path.endsWith(decodedFile) ||
                                        file.endsWith(t.path) ||
                                        decodedFile.endsWith(t.path),
                                );

                                if (track) {
                                    // Switch to 'all' collection to ensure track is visible
                                    currentCollection = "all";
                                    renderCollections();
                                    filterAndGroupTracks();

                                    const idx = filteredTracks.findIndex(
                                        (t) => t.path === track.path,
                                    );
                                    if (idx >= 0) {
                                        showToast(
                                            `Loading: ${track.title || track.path}`,
                                        );
                                        playTrack(idx).then(() => {
                                            // Switch to subsong if specified
                                            if (
                                                subsong > 1 &&
                                                wasmPlayer &&
                                                wasmPlayer.setSubsong
                                            ) {
                                                wasmPlayer.setSubsong(subsong);
                                                updateSubsongSelector();
                                                elements.subsongSelect.value =
                                                    subsong;
                                            }
                                            // Seek to time position if specified
                                            if (startTime > 0 && wasmPlayer) {
                                                const duration =
                                                    wasmPlayer.metadata
                                                        .duration_seconds || 0;
                                                if (duration > 0) {
                                                    wasmPlayer.seek_to_percentage(
                                                        startTime / duration,
                                                    );
                                                    updateProgressUI();
                                                }
                                            }
                                        });
                                    } else {
                                        showToast("Track not found");
                                    }
                                } else {
                                    showToast("Shared track not found");
                                }
                            }
                        })
                        .catch((err) =>
                            console.error("Failed to load catalog:", err),
                        );
                });
            });
        </script>
    </body>
</html>
